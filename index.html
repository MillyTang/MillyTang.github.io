<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="戴英 is all right">
<meta property="og:url" content="https://github.com/MillyTang/MillyTang.github.io/index.html">
<meta property="og:site_name" content="戴英 is all right">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="主体-客体联合创作">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/MillyTang/MillyTang.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>戴英 is all right</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">戴英 is all right</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">反方向的钟</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/MillyTang/MillyTang.github.io/2020/11/07/middle-life/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="主体-客体联合创作">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="戴英 is all right">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/07/middle-life/" class="post-title-link" itemprop="url">精卫填海-新编</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-07 16:30:39" itemprop="dateCreated datePublished" datetime="2020-11-07T16:30:39+08:00">2020-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-13 16:05:40" itemprop="dateModified" datetime="2020-12-13T16:05:40+08:00">2020-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章-预言成真"><a href="#第一章-预言成真" class="headerlink" title="第一章 预言成真"></a>第一章 预言成真</h2><blockquote>
<p>公欲渡河，公竟渡河，渡河而死，其耐公何</p>
</blockquote>
<p>炎帝之少女-女娃好游泳，已有西方上帝赠与的开光水晶球预示其将溺亡，其父及众人忧心忡忡勒令少女禁止下水，少女忤逆，于预言10年后在东海溺亡。</p>
<p>女娃死了，炎帝命人在三界搜寻其魂魄。最终在发鸠之山发现了新生的女娃，名曰精卫，可惜肉身损坏不能还魂。</p>
<!-- 变形记仿写 -->
<!-- 起初，精卫只觉得轻盈了许多，除了没有手-继续
过了几个月精卫发觉家人已经开始习惯女娃变成了一只鸟，吃食，居住已经完全按照鸟类的起居习惯设置-继续
精卫开始后悔 -->
<p>最终精卫大闹议事厅，离家出走，回到了发鸠之山，到东海去扔石子权当发泄，被好事者告与炎帝，炎帝默许。每日投2次，精卫力竭，然围观者众，每日投三次，力竭则停。<br>起初是愤怒驱使的自愿行为，随后被围观者怂恿每日投掷3次甚至更多，紧接着已经无以为继，当起了唐璜，谁多说一句开始啄人，最后已经没有围观者，精卫开始规律投石，心情好投2颗，心情不好只往海里拉泡屎，不仅自己拉，甚至在发鸠之山培养追随者一起拉屎，仇恨早已消失，此后在后悔，愤怒，失望，自闭，仇恨，平静中反复沉沦。</p>
<!-- -继续 -->
<!-- 真真是国产西西弗， -->
<p>东海之水并没有因为这几颗石子而减少，每日生物新生消亡吃喝拉撒，泥石冲刷几乎可以忽略不计。微不足道的石子等同于无效的复仇。</p>
<p>然而精卫向炎帝发问：复仇并没有解决她的痛苦，到底她的痛苦来源是什么？炎帝沉默，不日，<br>被扔进不周山的水晶球被炎帝又捡了回来，炎帝要求水晶球再做一则新的预言，要求显示如果女娃在第一个预言之后不再游泳后的命运，否则就会被扔进东海当成填海的边角料。</p>
<h2 id="新预言的故事"><a href="#新预言的故事" class="headerlink" title="新预言的故事"></a>新预言的故事</h2><p>女娃不再游泳，终日沉闷不语，在海边，湖边，河边一切有水的地方保持观望，仿佛下一秒就准备入水。不久开始生病，反反复复怎么都治不好，巫师问了情况，告诉炎帝在家里搞个大水桶，让女娃每日泡一泡，反正面积小高度小游不起来。女娃的病情开始有所缓解，但也终归没治好，就这样预言的10年之期很快过去，女娃离解禁的日子越来越近了。在最后一天女娃纵身一跃跳进了东海享受游泳，可惜由于多年没有练习女娃在海里体力不支，虽然最后被鲲背了上来，没有出事。但是对女娃来讲，生疏的技能，是空白的十年</p>
<p>可以说新预言的故事是女娃失去的十年，没有想到，因为听话反而受到了重重桎梏，<br>女娃可以选择自杀来反抗溺亡的命运，但是结局是没有变的，她最终依旧是在预言的时机死亡，反抗不仅没有作用，反而失去了最重要的东西。</p>
<h2 id="水晶球"><a href="#水晶球" class="headerlink" title="水晶球"></a>水晶球</h2><p>水晶球由于频繁干涉东方神话的独立发展（地狱事务）被谛听一脚踩碎了，形成了现代的溶洞景观。</p>
<h2 id="痛苦的根源"><a href="#痛苦的根源" class="headerlink" title="痛苦的根源"></a>痛苦的根源</h2><p>水晶球的2个预言基本宣告了女娃溺死的既定命运，女娃的死亡不是自杀，而是意外。即使开了上帝视角，<br>无论是选择什么都逃脱不了的意外死亡。那么在第二则预言后为什么女娃是失去了反抗被预示的既定命运，假如她信上帝的水晶球，那么死前她不信她信上帝，而死后是她不信她不信上帝。终日悔恨，被剥夺了正常生活的节奏，无法掌控自己的人生是核心痛苦。</p>
<p>人生所有的可能性被水晶球断言为真，失去了神秘感，新鲜感，再无让人探索的欲望，女娃不再是生机勃勃的女娃，女娃变成了木偶，为水晶球所操控的木偶。那么，她的痛苦是来源于水晶球吗？</p>
<p>假如没有水晶球，她依旧无法避免溺亡的结局，但是在溺亡之前她的所剩人生里没有被死亡的恐惧所控制，她是局部自由的。<br>没有水晶球也就没有新预言，她和家人还可以通过幻想「假如」来宽慰悲剧，安抚心灵。</p>
<p>水晶球的存在是人生痛苦的潘多拉魔盒，一旦知晓其存在就是悲剧，更遑论打开<br>可以说，人生少见 「种瓜的瓜」，几乎没有「只要」「就会」，更多的是「假如」「也许」，潘多拉打开了就只剩下「倒霉」「恐惧」「悲惨」「解脱」「自杀」「最终失去一切」。</p>
<p>现代中国神话已经偏离了当时东方神话发展的路线，已经失去了培养神棍和巫婆的土壤，那么，我们就可以脱离水晶球的魔咒了吗？</p>
<p>显然不能，水晶球只是一个隐喻。预示着命运的大致走向和人生发展历程的隐喻。最显而易见的是慢性疾病，乃至癌症。意志的衰弱不一定会拖垮躯体，只会干脆利落选择同归于尽，痛苦是短暂而单纯的，然而，躯体的衰弱几乎会拖垮意志，恶性循环最终走向共同死亡的结局。要说这两种有何不同，前者只包含一种单纯的痛苦，相当于电脑某个软件中了病毒，经过介入修复后可以康复和正常人无异，后者是多重痛苦，相当于电脑本身硬件出了问题，所有软件都得承受硬件卡顿崩溃的后果，最终不是更换硬件就是成为废弃的电子垃圾。</p>
<p>人当然不会成为一种废弃的电子垃圾，人只有一种结局一种命运：无可避免的死亡。区别在于，健康人的达摩克里斯剑或许永远不会到来，不健康的人24小时都在感受即将死亡的恐惧。</p>
<p>也许是明天，也许是下一刻，达摩克里斯斩下的前1秒，人生只剩下恐惧，没有了其他色彩，其他可能性，带着枷锁，每天除了等待死亡就是无所事事。</p>
<p>女娃死后尚且还可以转生为鸟投石泄愤，结果却是微不足道的复仇，甚至无法从「某种痛苦中」解脱，普通人别无选择，只剩下惨烈的自杀。</p>
<blockquote>
<p>「我永远不会选择自杀」- 加缪</p>
</blockquote>
<p>自杀之所以称得上惨烈，是因为这是最大且唯一的赌注，赌上生命的代价来反抗当下的命运，而结局自己是永远无法知晓的，刹那间却承受了人生最大的痛苦和一瞬间失去了全部的可能性。悲剧就在于，无法知晓反抗的结局，甚至生者也无法断定反抗是有效的。</p>
<p>无法判定的反抗，甚至包含反抗的结局，对于反抗本身来说是微不足道的，对于自己的命运来说却是毁灭性的。为了反抗既定命运，最终，却失去了一切。如加缪所说，自杀最终是无效的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/MillyTang/MillyTang.github.io/2020/11/07/three-easy-pieces/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="主体-客体联合创作">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="戴英 is all right">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/07/three-easy-pieces/" class="post-title-link" itemprop="url">three-easy-pieces</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-07 16:15:53" itemprop="dateCreated datePublished" datetime="2020-11-07T16:15:53+08:00">2020-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-13 15:35:33" itemprop="dateModified" datetime="2020-12-13T15:35:33+08:00">2020-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="操作系统阅读笔记-Three-Easy-Pieces"><a href="#操作系统阅读笔记-Three-Easy-Pieces" class="headerlink" title="操作系统阅读笔记 - Three Easy Pieces"></a>操作系统阅读笔记 - Three Easy Pieces</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol>
<li><a target="_blank" rel="noopener" href="http://pages.cs.wisc.edu/~remzi/OSTEP/">免费书籍PDF版本</a></li>
<li><a target="_blank" rel="noopener" href="http://pages.cs.wisc.edu/~remzi/OSTEP/Homework/homework.html">Homework</a></li>
<li><a href="https://github.com/remzi-arpacidusseau/ostep-projects">Projects</a></li>
<li><code>其余教辅资料</code>请向<code>contact@epubit.com.cn</code>发送邮件获取</li>
<li><a href="https://github.com/remzi-arpacidusseau/ostep-projects">ostep-Projects</a></li>
</ol>
<blockquote>
<p>鉴于书中所有示例全是<code>c</code>,(我暂时不太会)，所以为了容易理解，改写成了<code>nodejs</code>示例，请在文件夹下查看并运行，示例文件以章节为单位。</p>
</blockquote>
<h2 id="第一章-虚拟化"><a href="#第一章-虚拟化" class="headerlink" title="第一章 - 虚拟化"></a>第一章 - 虚拟化</h2><h3 id="第一节-CPU虚拟化-时分共享-进程（和空分共享-磁盘）"><a href="#第一节-CPU虚拟化-时分共享-进程（和空分共享-磁盘）" class="headerlink" title="第一节 - CPU虚拟化: 时分共享-进程（和空分共享-磁盘）"></a>第一节 - CPU虚拟化: 时分共享-进程（和空分共享-磁盘）</h3><h4 id="进程-操作系统为正在运行的程序提供的抽象"><a href="#进程-操作系统为正在运行的程序提供的抽象" class="headerlink" title="进程: 操作系统为正在运行的程序提供的抽象"></a>进程: 操作系统为正在运行的程序提供的抽象</h4><ol>
<li><p>进程的机器状态组成：</p>
<ul>
<li>内存</li>
<li>寄存器<ul>
<li>类型：程序计数器 &amp; 栈指针 &amp; 帧指针</li>
<li>3部分组成：状态，数据，指令</li>
</ul>
</li>
</ul>
</li>
<li><p>启动程序的过程：操作系统将程序的 <code>代码</code>和<code>静态数据</code>从磁盘加载到内存中，同时为程序的<code>运行时栈</code>和动态内存<code>堆</code>分配内存，最后启动程序，通常是程序入口（以<code>c</code>为例通常是main(）函数）。</p>
</li>
<li><p>默认情况下进程都有<code>3个文件描述符</code></p>
<ul>
<li>标准输入</li>
<li>标准输出</li>
<li>标准错误</li>
</ul>
</li>
<li><p>进程状态</p>
<ul>
<li>initial: 创建进程时的状态</li>
<li>running</li>
<li>ready</li>
<li>blocked</li>
<li>final: 僵死状态，待回收，有时候会出现父进程已经被回收但是子进程还在僵死状态时，此时有高一级的init进程回收，或者直接关机也行（有些垃圾程序只能关机。</li>
</ul>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程主要状态</span></span><br><span class="line">running  &lt;----------- 调度|取消调度 ----------&gt; ready</span><br><span class="line">  |                                             |</span><br><span class="line">  |---I/O: start---&gt; blocked --I/O: finished---&gt;|</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>上下文切换：操作系统保存和恢复该进程的寄存器内容的过程</li>
</ol>
<h4 id="进程API-系统调用陷入内核模式-区别于用户模式）"><a href="#进程API-系统调用陷入内核模式-区别于用户模式）" class="headerlink" title="进程API(系统调用陷入内核模式,区别于用户模式）"></a>进程API(系统调用陷入内核模式,区别于用户模式）</h4><blockquote>
<p>暂时只考虑单CPU的情况，不管是什么进程，CPU都有可能不断中断，切换任意进程，记住就算是亲父子（进程）也是不存在尊老爱幼的，谁先运行取决于CPU调度程序，所以执行顺序是不确定的。这种不确定性贯穿全文，是时候增加一点奇怪的不确定的知识了。</p>
</blockquote>
<ol>
<li>fork()：调用一次返回两次，争先恐后，父慈子孝</li>
</ol>
<ul>
<li>fork()虽然复制了父进程，但是由于写时复制拥有私有虚拟内存（用户栈），但是调用时返回值却不相同，子进程的返回值是0，父进程的返回值是子进程的pid。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有必要理解一下返回2次, 示例代码（c）如下：</span></span><br><span class="line"><span class="comment">// 头文件省略</span></span><br><span class="line"><span class="comment">// 让我们先假定子进程先运行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;您好，当前运行进程pid:%d&quot;</span>, <span class="keyword">int</span> getpid());</span><br><span class="line">  <span class="keyword">int</span> rc = fork()</span><br><span class="line">  <span class="comment">// 不考虑fork失败</span></span><br><span class="line">  <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// child process, 这里根据 rc 的返回值运行一次 - !!返回一次</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// parent process, 这里根据 rc 的返回值再运行一次 - !!返回两次</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>‼️注意：nodejs child_process.fork()虽然调用的是fork(2),但是却有所不同，衍生的子进程不会克隆当前父进程，只能通过IPC通信。。。这个命名太坑爹了。由于child_process.fork()是spawn的特例，所以使用child_process.spawn()作为示例。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 命令行执行: node ./os-notes/chapter-5.js 输出结果:</span></span><br><span class="line">此消息最新显示</span><br><span class="line">衍生的子进程的 pid：95650</span><br><span class="line">此进程的 pid 是 95649</span><br><span class="line">^C</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>exec()：鸠占鹊巢，臭不要脸</li>
</ol>
<blockquote>
<p>其他变体：execl(), execle(), execlp(), execv(), execvp()等。‼️成功调用不会返回。</p>
</blockquote>
<ul>
<li>exec()会直接覆写当前进程的代码，堆，栈和其他内存空间等。所以新的程序的虚拟地址不变，进程id不变</li>
</ul>
<ol start="3">
<li>wait()：非得父慈子孝的话，父进程可以通过调用<code>wait()</code>来确保自己后运行，此时2种情况：<ul>
<li>子进程先运行，然后父进程运行，天意如此。</li>
<li>父进程先运行，马上调用<code>wait()</code>，该系统调用会在子进程运行结束后返回，然后父进程输出。父慈子孝局面达成。</li>
</ul>
</li>
</ol>
<p>总结：这3个系统调用可以用来实现shell的很多有用的功能，例如重定向输出，管道的实现方式等。</p>
<blockquote>
<p>‼️问题：多进程程序是怎么抽象的？</p>
</blockquote>
<blockquote>
<p>进程是程序运行的一个实例，多进程就是程序运行的多个实例，<code>fork()</code>函数在新的子进程中运行相同的程序，子进程是父进程的复制品，进程上下文中将只有<code>栈</code>内数据不同（通过标记为私有的写时复制，复制时是完全相同的，运行后不同），<code>堆</code>、<code>代码</code>中的数据完全相同，因为fork复制进程时只是重新分配了一段虚拟内存复制原进程内容，并且标记为只读，可以通过绘制进程图来了解fork()。而通过<code>exec()</code>是在当前进程中的上下文中运行另一个新程序，将覆盖当前进程的地址空间（该进程所在的虚拟内存），但是<code>PID</code>(进程id)不变且继承了调用该函数时已打开的所有文件描述符（即包含<code>stdin</code>,<code>stdout</code>,<code>stderr</code>3个描述符）。更多内容请参考<code>csapp第八章异常控制流</code>一起食用。</p>
</blockquote>
<h4 id="机制-受限直接执行-limited-direct-execution-简称LDE协议"><a href="#机制-受限直接执行-limited-direct-execution-简称LDE协议" class="headerlink" title="机制: 受限直接执行(limited direct execution, 简称LDE协议)"></a>机制: 受限直接执行(limited direct execution, 简称LDE协议)</h4><blockquote>
<p>LDE协议的两个过程：1. 内核初始化陷阱表，并记住位置以便后续执行操作；2. 在进程中设置节点分配内存，用于保存陷入陷阱和返回的信息</p>
</blockquote>
<p>此协议下需要解决2个问题：</p>
<ol>
<li><p>受限制操作：引入<strong>用户模式(user mode)**，与之对应的是</strong>内核模式(kernel mode)**</p>
<ul>
<li>用户模式 和 系统交互 通过 内核模式暴露一些关键功能，如：访问文件系统，创建或销毁进程，或与其他进程通信以及分配更多内存等，称为系统调用。暴露功能的方式为在启动时设置 <strong>陷阱表</strong> 系统可以在 <strong><em>用户模式和内核模式</em></strong>中反复横跳</li>
<li>例如：用户模式下进程不能发出I/O请求 ，否则会导致进程终止</li>
</ul>
</li>
<li><p>进程切换：</p>
<ul>
<li>需要解决操作系统重新获取占据主动权的问题<ul>
<li>等待进程执行系统调用或者出错 - 该进程必须是个听话的好孩子才行</li>
<li>时钟中断</li>
</ul>
</li>
<li>保存进程上下文：2种可能，存储位置，存储内容和存储方式均不相同<ul>
<li>时钟中断时：用户寄存器有硬件隐式保存，使用该进程的<strong>内核栈</strong>。</li>
<li>调度程序切换进程：内核寄存器被软件OS保存，并存储在该进程的进程结构的内存中（‼️用户栈吗？）。</li>
</ul>
</li>
</ul>
</li>
<li><p>进程并发：锁？中断中禁止中断 - 禁止套娃？信号？ =&gt; 并发章节会详细讨论</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进程的地址空间：</span></span><br><span class="line">-------------------------</span><br><span class="line">| 内核栈（代码，数据，堆，栈）|  ----&gt; 用户代码不可见的内存</span><br><span class="line">--------------------------</span><br><span class="line">|   用户栈（运行时创建）     |</span><br><span class="line">--------------------------</span><br><span class="line">|  共享库的内存映射区域      |</span><br><span class="line">---------------------------</span><br><span class="line">|    运行时堆              |</span><br><span class="line">--------------------------</span><br><span class="line">|    读/写段（.data,.bss） |   ----&gt; 从可执行文件加载</span><br><span class="line">--------------------------</span><br><span class="line">|       只读代码段         |   ----&gt; 从可执行文件加载</span><br><span class="line">|（.init,.text,.rodata）  |</span><br><span class="line">--------------------------</span><br></pre></td></tr></table></figure>

<h4 id="进程调度：介绍"><a href="#进程调度：介绍" class="headerlink" title="进程调度：介绍"></a>进程调度：介绍</h4><blockquote>
<p>如何开发调度策略？ 想一想什么情况下要使用调度策略？然后弄清楚评价调度策略的关键指标是什么？</p>
</blockquote>
<pre><code>工作负载假设：
1. 每一个进程运行相同的时间 -&gt; 完全公平
2. 所有工作同时到达 -&gt; 平均响应时间
3. 一旦开始，每个进程运行到完成 -&gt; 运行时独占CPU
4. 所有进程不涉及I/O -&gt; 进程任务单一
5. 已知每个进程的运行时间 -&gt; 平均周转时间

调度指标：
1. 周转时间 = T完成时间 - T到达时间 =&gt; 性能指标
2. 公平
3. 响应时间 = T首次运行 - T到达时间
让我们设置一个时间函数 T(参与进程, 策略, [放开的假设条件])</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 工作进程假设: 基于逐渐放开以上5个假设条件</span></span><br><span class="line"><span class="comment"># test1: 假定目前的进程为（随机排序执行）：A（10s完成），B（10s完成），C（10s完成）</span></span><br><span class="line"> 10s  10s  10s</span><br><span class="line">-----|||||/////30s</span><br><span class="line">  A    B    C</span><br><span class="line"><span class="comment"># test2: 假定目前的进程为（随机排序执行）：A（100s完成），B（10s完成），C（10s完成） - 假设1</span></span><br><span class="line">         100s                   10s  10s</span><br><span class="line">-------------------------------|||||/////120s</span><br><span class="line">  A    B    C</span><br><span class="line"><span class="comment"># test3: 假定目前的进程为（随机排序执行）：A（100s完成）0s到达，B（10s完成）10s到达，C（10s完成）10s到达 - 假设1&amp;2</span></span><br><span class="line">         100s                   10s  10s</span><br><span class="line">-------------------------------|||||/////120s</span><br><span class="line">  A    B    C</span><br><span class="line"><span class="comment"># test4: 假定目前的进程为（随机排序执行）：A（100s完成）0s到达，B（10s完成）10s到达，C（10s完成）10s到达 - 假设1&amp;2&amp;3</span></span><br><span class="line"> 10s  10s  10s         90s</span><br><span class="line">-----|||||/////--------------------------120s</span><br><span class="line">  A    B    C           A</span><br></pre></td></tr></table></figure>

<ol>
<li><p>先进先出<strong>FIFO</strong>：队列</p>
<ul>
<li>平均周转时间： <ul>
<li>Tt(test1,FIFO,[]) = (10 + 20 + 30) / 3 = 20s</li>
<li>Tt(test2,FIFO,[1]) = (100 + 110 + 120) / 3 = 110s</li>
</ul>
</li>
</ul>
</li>
<li><p>最短任务优先<strong>SJF</strong>：FIFO下一旦出现单个长任务周转时间就很长，改进一下策略</p>
<ul>
<li>平均周转时间： <ul>
<li>Tt(test2,SJF,[1]) = (10 + 20 + 120) / 3 = 50s</li>
<li>Tt(test3,SJF,[1,2]) = (100 + 110-10 + 120-10 ) / 3 = 103.3s</li>
</ul>
</li>
</ul>
</li>
<li><p>最短完成时间优先<strong>STCF</strong>：SJF下短任务后到达时，长任务的周转时间并没有改善</p>
<ul>
<li><p>平均周转时间： </p>
<ul>
<li>Tt(test4,STCF,[1,2，3]) = (120 + 10 + 20) / 3 = 50s</li>
</ul>
<p>平均周转时间作为唯一指标的话，<strong>STCF</strong>表现良好。然鹅，引入分时系统后用户要求系统交互性好，所以引入响应时间作为新的指标<br>平均响应时间：Tr(test4,STCF,[1，2，3]) = (0 + 10 - 10 + 20 - 10) / 3 = 3.3s;<br>Tr(test1,FIFO,[]) = (0 + 10 - 10 + 20 - 10) / 3 = 3.3s;</p>
</li>
</ul>
</li>
<li><p>轮转<strong>RR(Round-Robin)</strong>: RR在一个时间片内运行，然后切换到队列的下一个工作，反复切换执行直到所有任务完成。</p>
<ul>
<li>时间片(time slice)的长度为时钟中断周期的倍数: 以下示例假设RR时间片为1s</li>
<li>平均响应时间：Tr(test1,SJF,[3]) = (0 + 10 + 20) / 3 = 10</li>
<li>平均响应时间：Tr(test1,RR,[3]) = (0 + 1 + 2) / 3 = 1</li>
<li>假设RR时间片为50ms: Tr(test1,RR,[3]) = (0 + 0.05 + 0.1) / 3 = 0.05s</li>
<li>RR效率的关键就是时间片的大小，然鹅时间片太小会频繁切换进程上下文，影响整体性能</li>
<li>摊销技术：将时间片的大小与切换上下文时间比较，1ms/10ms * 100% =  10% =&gt; 太大；1ms/100ms * 100% =  1% =&gt; 可以考虑</li>
<li>平均周转时间：Tt(test1,RR,[3]) = (26 + 28 + 30) / 3 = 28s ‼️周转时间太可怕惹</li>
</ul>
</li>
</ol>
<blockquote>
<p>两种调度程序：SJF,STCF 优化了周转时间，不利于响应时间；RR优化了响应时间，不利于周转时间，接下来需要放开假设4和假设5</p>
</blockquote>
<pre><code>结合I/O: 重叠，当一个进程被I/O阻塞，CPU可以切换其他进程运行
工作进程假设：A 50ms 运行10ms 发出I/O; B 50ms 没有I/O</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 没有重叠</span></span><br><span class="line">     A   A   A   A  A  B B B B B</span><br><span class="line">CPU: --  --  --  --  --||||||||||</span><br><span class="line">I/O:   --  --  --  --</span><br><span class="line"><span class="comment"># 重叠后</span></span><br><span class="line">CPU: --||--||--||--||--||</span><br><span class="line">I/O:   --  --  --  --</span><br></pre></td></tr></table></figure>
<blockquote>
<p>实际上调度程序并不知道每个工作的长度，下一章将通过构建一个调度程序利用最近的使用情况预测未来从而解决未知工作长度的问题：多级反馈队列</p>
</blockquote>
<h4 id="多级反馈队列-Multi-level-Feedback-Queue"><a href="#多级反馈队列-Multi-level-Feedback-Queue" class="headerlink" title="多级反馈队列(Multi-level Feedback Queue)"></a>多级反馈队列(Multi-level Feedback Queue)</h4><p>这是我遇到的第二个多级，真是相当美妙的思想，第一个多级是多级页表（这本书它出现在第二章，我发誓我没有跳着看书🐶）</p>
<blockquote>
<p>多级反馈队列要解决2个问题：优化周转时间 &amp;&amp; 降低响应时间 =&gt; 从历史中学习并预测</p>
</blockquote>
<pre><code>MLFQ基本规则：
MLFQ有许多独立的队列(queue),每个队列有不同的优先级(priority level)。一个进程只能在一个队列中，MLFQ总是优先执行较高优先级的进程，每个队列中的进程都拥有相同的优先级。
MLFQ的关键在于如何设置优先级。
规则1：若A的优先级 &gt; B的优先级，运行A
规则2：如果A的优先级 == B的优先级，RR（轮转）运行</code></pre>
<blockquote>
<p>刚定下2个规则就出现一个问题：AB两个进程在高优先级队列中，CD两个进程在低优先级队列中，假设AB任务一直运行，CD岂不是等到死都没法运行</p>
</blockquote>
<pre><code>如何改变优先级：
先考虑工作负载的类型：1.运行时间短，频繁放弃CPU的交互型工作；2.需要更多CPU时间，响应时间不重要的长时间计算密集型工作。
所以调整算法，增加规则：
规则3：工作进入系统，放到最高优先级 - 单个长工作（密集计算型）
规则4a：工作用完整个时间片后，降低到下一个优先级 - 长工作运行一段时间来了一个短工作（交互型）
规则4b：如果工作在时间片内动释放CPU，则优先级不变 - 交互型短工作执行大量I/O操作
以上实例皆运行良好，但是会出现长工作的饥饿问题：
系统中出现了大量的交互型短工作，导致长工作无法得到CPU
||
提升优先级：S太高长工作会饿死，太低交互型工作得不到合适的CPU时间比例
规则5：周期性提升所有工作的优先级，经过一段时间S，将系统中的素有工作重新加入最高优先级队列
更好的计时方式：修改规则4a &amp; 4b:
规则4：一旦工作用来了某一层的时间配额（无论中间主动放弃了多少次CPU），就降低优先级 =&gt; 防止恶意程序愚弄CPU</code></pre>
<blockquote>
<p>MLFQ调优及其他问题</p>
</blockquote>
<ol>
<li><p>配置多少优先级队列？</p>
</li>
<li><p>每一层队列的时间片设置为多大？</p>
</li>
<li><p>多久提升一次进程的优先级？</p>
<p> 大多数的MLFQ变体都支持不同队列可变的时间片长度。高优先级队列通常只有较短的时间片，因此这一层的交互工作可以更快的切换，相反，低优先级队列更多的是密集型工作</p>
</li>
</ol>
<h4 id="比例份额"><a href="#比例份额" class="headerlink" title="比例份额"></a>比例份额</h4><h4 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h4><h3 id="第二节-内存虚拟化"><a href="#第二节-内存虚拟化" class="headerlink" title="第二节 - 内存虚拟化"></a>第二节 - 内存虚拟化</h3><h4 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h4><h4 id="内存操作API"><a href="#内存操作API" class="headerlink" title="内存操作API"></a>内存操作API</h4><h4 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h4><ol>
<li>分段</li>
<li>分页<ul>
<li>快速地址转换</li>
<li>较小的表</li>
</ul>
</li>
<li>交换空间<ul>
<li>虚拟化磁盘空间</li>
<li>替换策略</li>
<li>虚拟内存技巧及示例</li>
</ul>
</li>
</ol>
<h4 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h4><h2 id="第二章-并发"><a href="#第二章-并发" class="headerlink" title="第二章 - 并发"></a>第二章 - 并发</h2><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h3 id="基于并发的数据结构"><a href="#基于并发的数据结构" class="headerlink" title="基于并发的数据结构"></a>基于并发的数据结构</h3><h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h3 id="常见并发问题"><a href="#常见并发问题" class="headerlink" title="常见并发问题"></a>常见并发问题</h3><h3 id="基于事件的并发"><a href="#基于事件的并发" class="headerlink" title="基于事件的并发"></a>基于事件的并发</h3><h4 id="事件循环："><a href="#事件循环：" class="headerlink" title="事件循环："></a>事件循环：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 伪代码</span></span><br><span class="line"><span class="keyword">while</span>(1) &#123;</span><br><span class="line">  events = getEvents()</span><br><span class="line">  <span class="keyword">for</span> (e <span class="keyword">in</span> events)</span><br><span class="line">    processEvents(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基于事件的服务器如何决定事件的发生顺序？尤其是网络和I/O</p>
</blockquote>
<pre><code>这里我们有一个例子，来首先了解一下select()函数：这个例子是从CSAPP上抄来的，select真是令人印象深刻
假设有一个echo服务器，它很强，一边接收网络请求，一边也可以响应用户的命令行键入请求。肿么办捏，先处理哪一个？更具体的代码示例请参考`《CSAPP》第12章第2节基于I/O多路复用的并发编程`
基于I/O多路复用技术的并发：使用select(),要求内核挂起进程，只有在一个或者多个I/O发生后才将控制权返回给应用程序（说人话：多个I/O请求注册到同一个select, select搞一个集合存储他们的状态，只要有I/O触发那么就由系统调用转回应用程序（用户模式））。</code></pre>
<h4 id="重要API-select-or-poll-系统调用"><a href="#重要API-select-or-poll-系统调用" class="headerlink" title="重要API: select() or poll() 系统调用"></a>重要API: select() or poll() 系统调用</h4><pre><code>select() 检查I/O描述符集合, 地址通过`readfds`,`writefds`, `errorfds`传入；
在每个集合中检查前nfds个描述符。
返回时，select()用给定请求操作准备好的描述符组成的子集替换给定的描述符集合，返回所有集合中就绪描述符的总数。</code></pre>
<blockquote>
<p>请注意select()的超时参数，常见用法是设置为NULL,但会导致无限期阻塞，直到有可用的就绪描述符。更好的做法是将超时设置为0，因此让调用的select()立即返回，这种方式提供了一种构建非阻塞（异步）事件循环的方法。</p>
</blockquote>
<pre><code>补充：阻塞与非阻塞接口
阻塞（同步）接口：在返回给调用者之前完成所有工作，非阻塞（异步）接口开始一些工作但是立即返回，从而让所有需要完成的工作都在后台完成。
通常阻塞调用的就是某种I/O。
非阻塞接口可用于任何类型的编程（例如使用线程），但在基于事件的方法中非常重要，因为阻塞的调用会阻塞所有进展。</code></pre>
<blockquote>
<p>‼️要分清楚并不是所有的非阻塞=异步，I/O就不是，非阻塞I/O!==异步I/O</p>
</blockquote>
<blockquote>
<p>使用单个CPU和基于事件的并发服务器，线程并发的程序中存在的抢占锁释放锁等问题不复存在，因为只有一个线程，不会被其他线程中断，但是请务必记住‼️不要阻塞基于事件的服务器，即node中，小心使用同步api.</p>
</blockquote>
<blockquote>
<p>阻塞系统的调用：I/O大boss如何解决？</p>
</blockquote>
<h4 id="异步I-O-Asyncchronous-I-O"><a href="#异步I-O-Asyncchronous-I-O" class="headerlink" title="异步I/O(Asyncchronous I/O):"></a>异步I/O(Asyncchronous I/O):</h4><ol>
<li>发出异步读取</li>
<li>如何才能知道I/O已经完成，并且缓冲区(aio_buf)已经有了数据: aio_error系统调用检查aiocbp引用的请求是否已经完成，如果完成则函数返回成功 <strong><em>（用0表示）</em></strong>,否则返回EINPROGRESS。对于每个未完成的AIO，应用程序可以调用aio_error来周期性的轮询(poll)系统，以确定所述I/O是否完成。这条看着很累，看下一条，宝贝。</li>
<li>poll一个I/O害行，1000个捏恐怕要累屎惹，所以某些系统提供了 <strong>基于中断(interrupt)</strong> 的方法。使用UNIX信号(signal)在异步I/O完成时通知一下程序，从而消除了轮询的痛苦，从今以后幸福快乐🥰。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AIO control block</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">aiocb</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> aio_fildes; <span class="comment">/* file descriptor */</span></span><br><span class="line">  <span class="keyword">off_t</span> aio_offser; <span class="comment">/* file offset */</span></span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">void</span> *aio_buf; <span class="comment">/* location of buffer */</span></span><br><span class="line">  <span class="keyword">size_t</span> aio_nbytes; <span class="comment">/* length of transfer */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// AIO 第一步： 向文件发出异步读取,发出成功后会立即返回并且应用程序可以继续工作</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_read</span><span class="params">(struct aiocb * aiocbp)</span></span>;</span><br><span class="line"><span class="comment">// AIO 第二步：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aio_error</span><span class="params">(<span class="keyword">const</span> struct aiocb *aiocbp)</span></span></span><br></pre></td></tr></table></figure>

<pre><code>补充：UNIX信号
信号提供了一种与进程通信的方式，可以将信号传递给应用程序，进程将暂停当前工作开始运行信号处理程序。完成后，该进程就回复先前的行为。
每个信号都有名字，如：HUP(挂断),INT(中断),SEGV(段违规)
内核或者程序都可以发出信号
可以用kill命令行工具发出信号，例如：
prompt &gt; ./main &amp; [3] 36705
prompt &gt; kill -HUP 36705
stop wakin&#39; me up...</code></pre>
<blockquote>
<p>在没有异步I/O的系统中，纯基于事件的方法无法实现。然鹅可以使用某种混合方法，使用线程池来管理未完成的I/O。参考《flash: an efficient and portable web server》来了解更多。</p>
</blockquote>
<h4 id="状态管理：基于事件的方法的另一个复杂问题"><a href="#状态管理：基于事件的方法的另一个复杂问题" class="headerlink" title="状态管理：基于事件的方法的另一个复杂问题"></a>状态管理：基于事件的方法的另一个复杂问题</h4><pre><code>当事件处理程序（事件循环中待处理的一个事件）发出异步I/O时，必须打包一些程序状态，以便下一个事件处理程序在I/O完成完成时使用。而基于线程的工作是不需要的，因为状态都保存在线程栈内。
node是如何处理这个问题的？
据鄙人看完的《深入浅出nodejs》后的一些笔记来看，node只是JS运行在单线程上，异步I/O另有线程：
部分线程通过阻塞或非阻塞&amp;轮询技术来完成数据获取，一个线程进行计算处理，通过线程间通信进行数据传递，实现异步I/O，也就是说node处理异步I/O是通过管理线程池来实现的。（没想到吧Σ(⊙▽⊙&quot;a）</code></pre>
<h4 id="太难了"><a href="#太难了" class="headerlink" title="太难了"></a>太难了</h4><p>当系统是多核CPU时，基于事件的一些简单性（不用加锁，不存在线程中断）就没有了，为了利用多个CPU，事件服务器必须并行运行多个事件处理程序，这时会出现「缓存一致性」？「加锁！必须加锁!!」,「发生缺页肿么办！被堵死了」等各种问题，现在先不要心塞，后面心塞的还多着呢，抽屉里放点硝酸甘油片啥的❤️。</p>
<blockquote>
<p>思考：同步I/O包含非阻塞I/O吗？异步I/O呢？</p>
</blockquote>
<p>I/O包含两步：请求和数据复制到缓冲区</p>
<table>
<thead>
<tr>
<th>I/O类型</th>
<th>请求</th>
<th>数据复制到缓冲区（aio_buf）</th>
<th>检查I/O是否完成的方法</th>
</tr>
</thead>
<tbody><tr>
<td>同步I/O</td>
<td>阻塞</td>
<td>阻塞</td>
<td>等前两步完成也就拿到了</td>
</tr>
<tr>
<td>非阻塞I/O</td>
<td>异步</td>
<td>阻塞</td>
<td>轮询，CPU很忙</td>
</tr>
<tr>
<td>I/O多路复用</td>
<td>异步</td>
<td>阻塞</td>
<td>轮询，CPU很忙（linux: epoll;）</td>
</tr>
<tr>
<td>异步I/O</td>
<td>异步</td>
<td>异步</td>
<td>中断时发信号(windows:IOCP)</td>
</tr>
</tbody></table>
<h4 id="技术总结：组合使用用于网络的select-接口和用于磁盘的AIO的调用（我猜node就是这样）"><a href="#技术总结：组合使用用于网络的select-接口和用于磁盘的AIO的调用（我猜node就是这样）" class="headerlink" title="技术总结：组合使用用于网络的select()接口和用于磁盘的AIO的调用（我猜node就是这样）"></a>技术总结：组合使用用于网络的select()接口和用于磁盘的AIO的调用（我猜node就是这样）</h4><p>node基于I/O（AIO（通过线程池来实现异步I/O））多路复用，所以是<strong>单线程（JS）、非阻塞、异步I/O</strong>，JS运行的单线程不会阻塞，但是I/O过程有可能是阻塞的，一旦遇到缺页就会卡住，就算主动去非洲客户也不会原谅你，OMG生活真是苦涩。</p>
<blockquote>
<p>思考: node单线程是怎么实现并发的？</p>
</blockquote>
<pre><code>nodejs使用cluster(集群)创建多个共享服务器端口的子进程来利用多核CPU系统
原理是：child_process.fork()衍生的是独立的子进程，和父进程只通过IPC管道来通信，可以根据需要随时关闭或者创建，不影响其他进程。
cluster分发连接：主进程负责监听接口，然后循环分发给各子进程。</code></pre>
<blockquote>
<p>思考：多个进程为什么可以共享服务器端口？</p>
</blockquote>
<pre><code>首先要知道监听描述符和已连接描述的区别，是并发服务器的基础，每次一个请求到达监听描述符时，可以在此时派发fork()一个新进程来连接已连接描述符与客户端通信。服务器调用server.listen(&#123;fd:7&#125;)将消息发给主进程，父进程将监听监听描述符并将句柄（handle）派发给子进程，子进程调用server.listen(handle)会显式监听handle而不是与父进程通信，子进程还会调用server.listen(0)会收到相同的「随机端口」，随机端口在第一次随机分配，而后都是已知的。
如果需要独立端口，可根据子进程的PID来生成。</code></pre>
<blockquote>
<p>思考again: nodejs 主进程挂了肿么办？所有相关子进程会一起被回收还是移交给主进程挂掉时立即重启一个新的父进程呢？</p>
</blockquote>
<pre><code>子进程死亡不会影响父进程, 不过子进程死亡时（线程组的最后一个线程，通常是“领头”线程死亡时），会向它的父进程发送死亡信号. 反之父进程死亡, 一般情况下子进程也会随之死亡, 但如果此时子进程处于可运行态、僵死状态等等的话, 子进程将被进程1（init 进程，由内核创建，是所有进程的祖先）收养，从而成为孤儿进程. 另外, 子进程死亡的时候（处于“终止状态”），父进程没有及时调用 wait() 或 waitpid() 来返回死亡进程的相关信息，此时子进程还有一个 PCB (Process Control Block进程控制结构)残留在进程表中，被称作僵尸进程.</code></pre>
<blockquote>
<p>思考：让我们来想想 <strong><em>nodejs进程管理</em></strong> 是怎么实现的?</p>
</blockquote>
<h2 id="第三章-持久性"><a href="#第三章-持久性" class="headerlink" title="第三章 - 持久性"></a>第三章 - 持久性</h2><h3 id="I-O-设备"><a href="#I-O-设备" class="headerlink" title="I/O 设备"></a>I/O 设备</h3><h3 id="磁盘驱动器"><a href="#磁盘驱动器" class="headerlink" title="磁盘驱动器"></a>磁盘驱动器</h3><h3 id="RAID-冗余磁盘阵列"><a href="#RAID-冗余磁盘阵列" class="headerlink" title="RAID 冗余磁盘阵列"></a>RAID 冗余磁盘阵列</h3><h3 id="文件与目录"><a href="#文件与目录" class="headerlink" title="文件与目录"></a>文件与目录</h3><h3 id="文件系统的实现"><a href="#文件系统的实现" class="headerlink" title="文件系统的实现"></a>文件系统的实现</h3><h4 id="局部性和快速文件系统"><a href="#局部性和快速文件系统" class="headerlink" title="局部性和快速文件系统"></a>局部性和快速文件系统</h4><h4 id="崩溃一致性"><a href="#崩溃一致性" class="headerlink" title="崩溃一致性"></a>崩溃一致性</h4><h4 id="日志结构文件系统"><a href="#日志结构文件系统" class="headerlink" title="日志结构文件系统"></a>日志结构文件系统</h4><h4 id="数据完整性和保护"><a href="#数据完整性和保护" class="headerlink" title="数据完整性和保护"></a>数据完整性和保护</h4><h4 id="思考：数据库"><a href="#思考：数据库" class="headerlink" title="思考：数据库"></a>思考：数据库</h4><h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><h3 id="通信基础"><a href="#通信基础" class="headerlink" title="通信基础"></a>通信基础</h3><h3 id="Sun的网络文件系统-NFS-Network-File-System"><a href="#Sun的网络文件系统-NFS-Network-File-System" class="headerlink" title="Sun的网络文件系统 NFS (Network File System)"></a>Sun的网络文件系统 NFS (Network File System)</h3><h3 id="Andrew-文件系统-AFS"><a href="#Andrew-文件系统-AFS" class="headerlink" title="Andrew 文件系统 AFS"></a>Andrew 文件系统 AFS</h3><h3 id="思考：与计算机网络的联系"><a href="#思考：与计算机网络的联系" class="headerlink" title="思考：与计算机网络的联系"></a>思考：与计算机网络的联系</h3><h4 id="TCP与UDP的比较"><a href="#TCP与UDP的比较" class="headerlink" title="TCP与UDP的比较"></a>TCP与UDP的比较</h4><h4 id="TCP握手挥手机制"><a href="#TCP握手挥手机制" class="headerlink" title="TCP握手挥手机制"></a>TCP握手挥手机制</h4><h4 id="TCP与UDP的丢包处理"><a href="#TCP与UDP的丢包处理" class="headerlink" title="TCP与UDP的丢包处理"></a>TCP与UDP的丢包处理</h4><h4 id="实践：局部网络中的通信-wireless"><a href="#实践：局部网络中的通信-wireless" class="headerlink" title="实践：局部网络中的通信-wireless"></a>实践：局部网络中的通信-wireless</h4><h4 id="推荐阅读：以操作系统为基础按顺序阅读以下书籍"><a href="#推荐阅读：以操作系统为基础按顺序阅读以下书籍" class="headerlink" title="推荐阅读：以操作系统为基础按顺序阅读以下书籍"></a>推荐阅读：以操作系统为基础按顺序阅读以下书籍</h4><ol>
<li>CSAPP</li>
<li>unix环境高级编程</li>
<li>图解TCP/IP &amp;&amp; Wireshark网络分析就是这么简单</li>
<li>深入浅出nodejs</li>
<li>算法</li>
<li>数据库概论</li>
<li>SQL基础教程</li>
<li>Redis深度历险：核心原理与应用实践</li>
<li>Redis设计与实现</li>
<li>数据密集型应用系统设计</li>
</ol>
<!-- ### 思考：与CDN的比较 -->

<!-- ## 梳理：数据结构和算法的应用
1. LRU... -->

<!-- ## 练习
### Homework(js版本)
### Projects(js版本) -->

<!-- ## 待补充：《UNIX环境高级编程》
### 文件I/O
### 终端I/O
### 文件与目录
### 进程
### 线程
### 信号
### IPC -->


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/MillyTang/MillyTang.github.io/2020/11/07/Docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="主体-客体联合创作">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="戴英 is all right">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/07/Docker/" class="post-title-link" itemprop="url">Docker</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-07 16:10:21" itemprop="dateCreated datePublished" datetime="2020-11-07T16:10:21+08:00">2020-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-10 18:38:42" itemprop="dateModified" datetime="2020-11-10T18:38:42+08:00">2020-11-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Set-up-your-Docker-environment"><a href="#Set-up-your-Docker-environment" class="headerlink" title="Set up your Docker environment"></a>Set up your Docker environment</h2><ul>
<li>准备工作： 下载</li>
<li>Dockerfile: 项目中根目录下增加一个Dockerfile配置文件，以前端项目为例</li>
<li>docker 几个概念和常用命令:<ul>
<li>概念：<ul>
<li><code>container</code>: 容器，一个被隔离的且有自己的文件系统，网络的正常的操作系统进程，进程树独立于主机</li>
<li><code>image</code>: 镜像，一个配置文件用来生成容器的</li>
</ul>
</li>
<li>常用命令：<ol>
<li><code>docker run your-Docker-image</code>,</li>
<li><code>docker ps --all</code></li>
<li>Build and test: <code>docker build --tag tagName:Vsesion .</code></li>
<li>Run your image as a container: <code>docker run --publish 8000:8080 --detach --name container-alias-name tagName:Vsesion</code></li>
<li>Delete container: <code>docker rm --force container-alias-name</code></li>
</ol>
</li>
</ul>
</li>
</ul>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FORM: 从 node:12.18.1 这个线上的image继承</span></span><br><span class="line"><span class="keyword">FROM</span> node:<span class="number">12.18</span>.<span class="number">1</span></span><br><span class="line"><span class="comment"># ENV 执行环境是生产环境还是开发环境</span></span><br><span class="line"><span class="keyword">ENV</span> NODE_ENV=production</span><br><span class="line"><span class="comment"># WORKDIR: 工作目录/app</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /app</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> [<span class="string">&quot;package.json&quot;</span>, <span class="string">&quot;package-lock.json*&quot;</span>, <span class="string">&quot;./&quot;</span>]</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> npm install --production</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> . .</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> [<span class="string">&quot;node&quot;</span>, <span class="string">&quot;server.js&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h2 id="Build-and-run-your-image-In-projects"><a href="#Build-and-run-your-image-In-projects" class="headerlink" title="Build and run your image: In projects"></a>Build and run your image: In projects</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/MillyTang/MillyTang.github.io/2020/11/04/shell-notes/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="主体-客体联合创作">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="戴英 is all right">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/04/shell-notes/" class="post-title-link" itemprop="url">Shell Notes</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-04 13:11:30" itemprop="dateCreated datePublished" datetime="2020-11-04T13:11:30+08:00">2020-11-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-12-13 16:55:13" itemprop="dateModified" datetime="2020-12-13T16:55:13+08:00">2020-12-13</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="第一章：概览"><a href="#第一章：概览" class="headerlink" title="第一章：概览"></a>第一章：概览</h2><p><code>shell:</code> 计算机提供给用户的一种文字接口，核心功能 - 允许用户执行程序，输入并获取某种半结构化的输出；<br>shell是一个编程环境，所以它具备变量、条件、循环和函数。<br>当你在 shell 中执行命令时，实际上是在执行一段 shell 可以解释执行的简短代码。<br>如果要求 shell 执行某个指令，但是该指令并不是 shell 所了解的编程关键字，那么它会去查询环境变量 $PATH，搜索由<code>:</code>分隔的一系列目录，基于名字搜索该执行程序</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="shell的界面（bash-zsh）"><a href="#shell的界面（bash-zsh）" class="headerlink" title="shell的界面（bash@zsh）"></a>shell的界面（bash@zsh）</h4><p><code>#</code> 开头是注释，提示信息，<code>hostname</code>是主机名，<code>~</code>指当前工作目录是<code>home</code>，<code>$</code>表示当前用户不是<code>root</code>用户，<code>Last login...</code>打开一个新的window就会出现该提示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Last login: Tue Nov  3 17:59:22 on ttys007</span><br><span class="line"><span class="comment"># hostname @ MacBook-Air in ~ [13:34:52]</span></span><br><span class="line">$</span><br></pre></td></tr></table></figure>

<h4 id="基础命令-使用-man-command-来了解这些命令的详细信息"><a href="#基础命令-使用-man-command-来了解这些命令的详细信息" class="headerlink" title="基础命令: 使用 man [command]来了解这些命令的详细信息"></a>基础命令: 使用 <code>man [command]</code>来了解这些命令的详细信息</h4><blockquote>
<p>内置命令&amp;变量: date, echo, which echo, $PATH, ls, cd, pwd, /(root path), ./(current path,relative), ../(parent path, relative), mv(用于重命名或移动文件), mkdir(新建文件夹), cp(复制文件)</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="comment"># -l  use a long listing format</span></span><br><span class="line">$ ls -l /home</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x   3 user  staff   96 12  9  2016 beginning</span><br><span class="line">  _3_           /|\</span><br><span class="line">   |_____________|</span><br><span class="line"><span class="comment"># d -&gt; directory</span></span><br><span class="line"><span class="comment"># 然后接下来的九个字符，每三个字符构成一组</span></span><br><span class="line"><span class="comment"># rwx -&gt; 指(user)文件所有者的权限</span></span><br><span class="line"><span class="comment"># r-x -&gt; 用户(staff)的权限，`-x`代表staff没有执行文件(x)的权限</span></span><br><span class="line"><span class="comment"># r-x -&gt; 其他客人用户的权限</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Last login: Fri Nov  6 18:13:54 on ttys007</span><br><span class="line"><span class="comment"># username @ MacBook-Air in ~ [13:34:52]</span></span><br><span class="line">$ date</span><br><span class="line">2020年11月 7日 星期六 16时09分15秒 CST</span><br><span class="line">$ <span class="built_in">echo</span> hello DaiYing</span><br><span class="line">hello DaiYing</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line">/Users/hostname/.yarn/bin:/Users/hostname/.config/yarn/global/node_modules/.bin:/Users/hostname/.avn/bin:/Users/hostname/.nvm/versions/node/v8.9.4/bin:/usr/<span class="built_in">local</span>/bin:/usr/bin:/bin:/usr/sbin:/sbin:/Users/hostname/.rvm/bin</span><br><span class="line">$ <span class="built_in">which</span> <span class="built_in">echo</span></span><br><span class="line"><span class="built_in">echo</span>: shell built-in <span class="built_in">command</span></span><br></pre></td></tr></table></figure>

<h4 id="在程序间建立连接"><a href="#在程序间建立连接" class="headerlink" title="在程序间建立连接"></a>在程序间建立连接</h4><blockquote>
<p>输入流，输出流，重定向(重定向方向 &lt;, &gt;重定向方向, &gt;&gt;追加内容方向)<br>| (pipes)管道操作符，连接左边的输入到右边的输出<br>sudo(super user do)根用户</p>
</blockquote>
<h4 id="练习题：Mac-OSX系统"><a href="#练习题：Mac-OSX系统" class="headerlink" title="练习题：Mac OSX系统"></a>练习题：Mac OSX系统</h4><ul>
<li>新建tmp/missing/semester文件，按行向semester输入内容</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># username @ MacBook-Air in ~ [16:52:44]</span></span><br><span class="line">$ mkdir tmp</span><br><span class="line">$ <span class="built_in">cd</span> tmp/</span><br><span class="line">$ mkdir missing</span><br><span class="line">$ <span class="built_in">cd</span> missing/</span><br><span class="line">$ touch semester</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;#!/bin/sh&#x27;</span> &gt; semester</span><br><span class="line"><span class="comment"># 追加第二行内容</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;curl --head --silent https://missing.csail.mit.edu&#x27;</span> &gt;&gt; semester</span><br><span class="line">$ vim semester</span><br><span class="line"><span class="comment"># :q退出</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="第二章：-shell工具和脚本"><a href="#第二章：-shell工具和脚本" class="headerlink" title="第二章： shell工具和脚本"></a>第二章： shell工具和脚本</h2><h3 id="字符串区别"><a href="#字符串区别" class="headerlink" title="字符串区别"></a>字符串区别</h3><ul>
<li><code>&#39;&#39;</code>单引号可以转义</li>
<li><code>&quot;&quot;</code>双引号不行</li>
</ul>
<blockquote>
<p>shell访问变量: 前缀$+变量名；如：$foo</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ foo=bar</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$foo</span>&quot;</span></span><br><span class="line">bar</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;$foo&#x27;</span></span><br><span class="line"><span class="variable">$foo</span></span><br></pre></td></tr></table></figure>

<h3 id="shell脚本控制流"><a href="#shell脚本控制流" class="headerlink" title="shell脚本控制流"></a>shell脚本控制流</h3><blockquote>
<p>Here is an example of a func that creates a dir and  cd into it</p>
</blockquote>
<ul>
<li><code>$0</code>-script command</li>
<li><code>$1</code>~<code>$9</code>- script command的参数</li>
<li><code>$@</code> script command的所有参数</li>
<li><code>$#</code>- script command参数个数</li>
<li><code>$?</code>-上一个script command</li>
<li><code>$$</code>-当前scrippt command的PID(Process Identification number)</li>
<li><code>!!</code>-使用<code>sudo !!</code>执行上一个command(包含所有参数)</li>
<li><code>$_</code>-上一个命令的最后一个参数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># testShellFunc.sh</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="function"><span class="title">mcd</span></span>() &#123;</span><br><span class="line">  mkdir -p <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">  <span class="built_in">cd</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># bash执行testShellFunc.sh文件</span></span><br><span class="line"><span class="comment"># source 可执行shell文件</span></span><br><span class="line"><span class="built_in">source</span> testShellFunc.sh</span><br><span class="line"><span class="comment"># cd 是在 mcd()内部，针对的是子shell, 不影响外部，所以不能直接执行 ./testShellFunc.sh</span></span><br></pre></td></tr></table></figure>

<h3 id="短路操作符"><a href="#短路操作符" class="headerlink" title="短路操作符"></a>短路操作符</h3><blockquote>
<p>||, &amp;&amp;, ;</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 和js的短路操作符结果相似，这里唯一特别的是「;」，始终能运行短路后面的语句</span></span><br><span class="line"><span class="literal">true</span> ; <span class="built_in">echo</span> <span class="string">&#x27;I can run!&#x27;</span></span><br><span class="line"><span class="comment"># 输出：I can run!</span></span><br><span class="line"><span class="literal">false</span> ; <span class="built_in">echo</span> <span class="string">&#x27;I can run again!&#x27;</span></span><br><span class="line"><span class="comment"># 输出：I can run again!</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>linux中： | and ||, &amp; and &amp;&amp;, &amp;&gt; and &gt; 的区别：<br>&amp; 表示任务在后台执行，如要在后台运行<br>| 表示管道，上一条命令的输出，作为下一条命令参数(输入)</p>
<blockquote>
<p>符号是指：将正常信息重定向; &amp;&gt;可以将错误信息或者普通信息都重定向输出</p>
</blockquote>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/MillyTang/MillyTang.github.io/2020/11/03/sad-punk/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="主体-客体联合创作">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="戴英 is all right">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/03/sad-punk/" class="post-title-link" itemprop="url">The Adventure of DaiYing</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-03 18:38:08" itemprop="dateCreated datePublished" datetime="2020-11-03T18:38:08+08:00">2020-11-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-04 12:56:50" itemprop="dateModified" datetime="2020-11-04T12:56:50+08:00">2020-11-04</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/MillyTang/MillyTang.github.io/2020/10/30/new-lemon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="主体-客体联合创作">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="戴英 is all right">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/new-lemon/" class="post-title-link" itemprop="url">git ssh 本机多账号</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-30 15:18:08" itemprop="dateCreated datePublished" datetime="2020-10-30T15:18:08+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-05 13:14:17" itemprop="dateModified" datetime="2020-11-05T13:14:17+08:00">2020-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="本机如何使用ssh连接多个GitHub账号来生产多倍快乐"><a href="#本机如何使用ssh连接多个GitHub账号来生产多倍快乐" class="headerlink" title="本机如何使用ssh连接多个GitHub账号来生产多倍快乐"></a>本机如何使用ssh连接多个GitHub账号来生产多倍快乐</h1><blockquote>
<p>github账号对应的邮箱账号个数</p>
</blockquote>
<h2 id="生成过程"><a href="#生成过程" class="headerlink" title="生成过程"></a>生成过程</h2><ol>
<li><p>按照<a target="_blank" rel="noopener" href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/connecting-to-github-with-ssh">generating new ssh key and adding it to the ssh-agent</a>指示操作</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打开命令行</span></span><br><span class="line"><span class="comment"># 查看现有的ssh keys</span></span><br><span class="line">ls -al ~/.ssh</span><br><span class="line"><span class="comment"># 如果有以下文件中的一个，则代表待会创建的就是第二份的 ssh publick id_rsa</span></span><br><span class="line">id_rsa.pub id_ecdsa.pub id_ed25519.pub</span><br><span class="line"><span class="comment"># Generating a new ssh key by your_email@example.com</span></span><br><span class="line">ssh-keygen -t rsa -b 4096 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br><span class="line"><span class="comment"># 命令行提示</span></span><br><span class="line">&gt; Generating public/private rsa key pair.</span><br><span class="line"><span class="comment"># 不要直接回车，否则会覆盖已有的，重新键入: 比如文件名这里改成了 id_dubble_rsa，记住这个文件名！</span></span><br><span class="line">&gt; Enter a file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/Users/you/.ssh/id_rsa): /Users/you/.ssh/id_dubble_rsa</span><br><span class="line"><span class="comment"># 接下来按照提示键入</span></span><br><span class="line">&gt; Enter passphrase (empty <span class="keyword">for</span> no passphrase): [Type a passphrase]</span><br><span class="line">&gt; Enter same passphrase again: [Type passphrase again]</span><br></pre></td></tr></table></figure>
</li>
<li><p>将新的ssh key添加到 ssh-agent</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">&gt; Agent pid 59566</span><br><span class="line"><span class="comment"># 如果你是 mac 用户，还需要修改 ~/.ssh/config文件</span></span><br><span class="line">open ~/.ssh/config</span><br><span class="line"><span class="comment"># 如果没有这个config文件，则手动生成一个</span></span><br><span class="line">touch ~/.ssh/config</span><br><span class="line"><span class="comment"># 记事本会打开这个文件</span></span><br></pre></td></tr></table></figure>

 <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">AddKeysToAgent yes</span><br><span class="line">UseKeychain yes</span><br><span class="line"># id_dubble_rsa就是刚刚手动键入的文件名</span><br><span class="line">IdentityFile ~/.ssh/id_dubble_rsa</span><br></pre></td></tr></table></figure>

 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最后一步添加</span></span><br><span class="line">ssh-add -K ~/.ssh/c</span><br></pre></td></tr></table></figure>
</li>
<li><p>将新的 ssh key 添加到GitHub账号</p>
 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制对应的.pub文件内容</span></span><br><span class="line">pbcopy &lt; ~/.ssh/id_dubble_rsa.pub</span><br><span class="line"><span class="comment"># 打开 GitHub setting 页面的 ssh配置，将新的 key 复制进去即可</span></span><br><span class="line"><span class="comment"># 查看是否连接正确</span></span><br><span class="line">ssh -vT git@github.com</span><br><span class="line"><span class="comment"># 如果出现以下内容则成功！</span></span><br><span class="line">Hi your-github-name! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="使用之前"><a href="#使用之前" class="headerlink" title="使用之前"></a>使用之前</h2><blockquote>
<p>操作：1. 本地仓库推到远程；2. 远程仓库克隆下来 之前需要改下 <code>git config</code></p>
</blockquote>
<h3 id="由于之前一直是单账号，所以现在要处理一下全局git配置"><a href="#由于之前一直是单账号，所以现在要处理一下全局git配置" class="headerlink" title="由于之前一直是单账号，所以现在要处理一下全局git配置"></a>由于之前一直是单账号，所以现在要处理一下全局git配置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本机全局git配置，注意最后2行</span></span><br><span class="line"><span class="comment"># user.name=&#x27;your-github-name&#x27;</span></span><br><span class="line"><span class="comment"># user.email=&#x27;your-register-email&#x27;</span></span><br><span class="line">git config -l</span><br><span class="line"><span class="comment"># 这2个值是第一个账号的值</span></span><br><span class="line"><span class="comment"># 现在如果进行新的github账号的各种仓库的操作，则需要进入到相关文件夹</span></span><br><span class="line"><span class="comment"># 使用一个空文件夹模拟过程</span></span><br><span class="line">mkdir new-github-repo</span><br><span class="line"><span class="built_in">cd</span> new-github-repo/</span><br><span class="line"><span class="comment"># git 初始化，根据提示操作</span></span><br><span class="line">git init</span><br><span class="line"><span class="comment"># 关键步骤：</span></span><br><span class="line"><span class="comment"># 清除全局配置</span></span><br><span class="line">git config --global <span class="built_in">unset</span> user.name your-old-github-name</span><br><span class="line">git config --global <span class="built_in">unset</span> user.email your-old-register-email-address</span><br><span class="line"><span class="comment"># 局部设置</span></span><br><span class="line">git config --<span class="built_in">local</span> user.name your-new-github-name</span><br><span class="line">git config --global <span class="built_in">unset</span> user.email your-new-register-email-address</span><br><span class="line"><span class="comment"># 最后再检查一下</span></span><br><span class="line">git config -l</span><br><span class="line"><span class="comment"># 如果已经进行了 git commit msg操作，不用慌，还可以修改</span></span><br><span class="line"><span class="comment"># git commit --amend --reset-author</span></span><br></pre></td></tr></table></figure>

<h2 id="本地多个项目有不同的node版本管理"><a href="#本地多个项目有不同的node版本管理" class="headerlink" title="本地多个项目有不同的node版本管理"></a>本地多个项目有不同的node版本管理</h2><ul>
<li>nvm &amp; avn 联合控制</li>
<li>项目中增加一个<code>.node-version</code> or <code>.nvmrc</code>文件即可,内容为该项目的node版本数字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/MillyTang/MillyTang.github.io/2020/10/30/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="主体-客体联合创作">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="戴英 is all right">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/10/30/hello-world/" class="post-title-link" itemprop="url">Hexo & travis bot坑爹的自动部署</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-10-30 15:17:29" itemprop="dateCreated datePublished" datetime="2020-10-30T15:17:29+08:00">2020-10-30</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-11-05 19:06:41" itemprop="dateModified" datetime="2020-11-05T19:06:41+08:00">2020-11-05</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="没有修改主题前的自动部署流程十分顺滑"><a href="#没有修改主题前的自动部署流程十分顺滑" class="headerlink" title="没有修改主题前的自动部署流程十分顺滑"></a>没有修改主题前的自动部署流程十分顺滑</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># git:main 分支</span></span><br><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br><span class="line">$ git add .</span><br><span class="line">$ git commit msg</span><br><span class="line">$ git push</span><br><span class="line"><span class="comment"># 剩下的交给travis.bot发布到gh-pages分支</span></span><br></pre></td></tr></table></figure>

<h2 id="一切变故来源于更换了更好看的主题"><a href="#一切变故来源于更换了更好看的主题" class="headerlink" title="一切变故来源于更换了更好看的主题"></a>一切变故来源于更换了更好看的主题</h2><p>  同样操作一遍，线上的直接404，在.travis.yml脚本中增加了 npm install,就此成功了一次，当第三次推送时又不行了，本地server完全OK，查看node版本，换成.travis.yml中的10.22.0,再clean掉，不行，第五次，第六次，尝试了多种办法还是不行，一气之下改成私有部署，本地1个命令，真香。</p>
<h3 id="推荐私有部署-hexo-deployer-git-再无头秃烦恼"><a href="#推荐私有部署-hexo-deployer-git-再无头秃烦恼" class="headerlink" title="推荐私有部署 hexo-deployer-git 再无头秃烦恼"></a>推荐私有部署 hexo-deployer-git 再无头秃烦恼</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="comment"># your-git-repo-url</span></span><br><span class="line">  <span class="attr">token:</span> <span class="string">$GH_TOKEN</span> <span class="comment"># 你的token, 跟在travis.com上配置是同一个token,这里写token名：$GH_TOKEN</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span> <span class="comment"># 发布分支</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 配置完成后接下来命令行：直接一个命令</span></span><br><span class="line">$ npx hexo clean &amp;&amp; npx hexo deploy</span><br><span class="line"><span class="comment"># 接下来就是vscode-auth =&gt; github.com的认证过程，按照提示操作即可</span></span><br><span class="line"><span class="comment"># 如果碰到 关键字中有 LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443错误，更换网络，不要用流量</span></span><br><span class="line"><span class="comment"># 如果碰到 Authentication failed for &#x27;https://github.com/xxx/xxx.github.io/&#x27;，那就是travis上配置的$ $GH_TOKEN与.config.yml中的不一致</span></span><br><span class="line"><span class="comment"># 这两个问题都没碰到，基本成功</span></span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">主体-客体联合创作</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">主体-客体联合创作</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
