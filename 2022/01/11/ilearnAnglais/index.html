<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"github.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第七章 - Subtyping 儿类型关系类型之间的关系-儿类型关系：1. 在TS中消除类型的歧义；2.安全的反序列化；3.错误情况的值；4.和类型、集合以及函数的类型兼容。 在TS中区分相似的类型回顾磅力秒那个例子，使用了 unique symbol 来区分两个相似类型，确保类型检查器不会把一个类型的值解释为另一个类型的值 - 通过模拟名义Subtype(亚类型、儿类型)👉见下文 省略NsTy">
<meta property="og:type" content="article">
<meta property="og:title" content="编程与类型系统 - 类型部分&amp;补充知识">
<meta property="og:url" content="https://github.com/MillyTang/MillyTang.github.io/2022/01/11/ilearnAnglais/index.html">
<meta property="og:site_name" content="Comfortably Numb">
<meta property="og:description" content="第七章 - Subtyping 儿类型关系类型之间的关系-儿类型关系：1. 在TS中消除类型的歧义；2.安全的反序列化；3.错误情况的值；4.和类型、集合以及函数的类型兼容。 在TS中区分相似的类型回顾磅力秒那个例子，使用了 unique symbol 来区分两个相似类型，确保类型检查器不会把一个类型的值解释为另一个类型的值 - 通过模拟名义Subtype(亚类型、儿类型)👉见下文 省略NsTy">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-11T07:40:07.000Z">
<meta property="article:modified_time" content="2022-02-09T07:29:28.410Z">
<meta property="article:author" content="主体-客体联合创作">
<meta property="article:tag" content="typeScript, javaScript, 编程与类型系统">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://github.com/MillyTang/MillyTang.github.io/2022/01/11/ilearnAnglais/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>编程与类型系统 - 类型部分&补充知识 | Comfortably Numb</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Comfortably Numb</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">反方向的钟</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://github.com/MillyTang/MillyTang.github.io/2022/01/11/ilearnAnglais/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="主体-客体联合创作">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Comfortably Numb">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          编程与类型系统 - 类型部分&补充知识
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-01-11 15:40:07" itemprop="dateCreated datePublished" datetime="2022-01-11T15:40:07+08:00">2022-01-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-02-09 15:29:28" itemprop="dateModified" datetime="2022-02-09T15:29:28+08:00">2022-02-09</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="第七章-Subtyping-儿类型关系"><a href="#第七章-Subtyping-儿类型关系" class="headerlink" title="第七章 - Subtyping 儿类型关系"></a>第七章 - Subtyping 儿类型关系</h2><p>类型之间的关系-儿类型关系：1. 在TS中消除类型的歧义；2.安全的反序列化；3.错误情况的值；4.和类型、集合以及函数的类型兼容。</p>
<h3 id="在TS中区分相似的类型"><a href="#在TS中区分相似的类型" class="headerlink" title="在TS中区分相似的类型"></a>在TS中区分相似的类型</h3><p>回顾磅力秒那个例子，使用了 <code>unique symbol</code> 来区分两个相似类型，确保类型检查器不会把<code>一个类型的值</code>解释为<code>另一个类型的值</code> - 通过<code>模拟名义Subtype(亚类型、儿类型)</code>👉见下文</p>
<figure class="highlight ts"><figcaption><span>省略NsType和LbsType的unique symbol唯一属性</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> NsType: unique symbol;</span><br><span class="line"><span class="keyword">class</span> Ns &#123;</span><br><span class="line">  value: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// [NsType]: void;</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> LbfsType: unique symbol;</span><br><span class="line"><span class="keyword">class</span> Lbfs &#123;</span><br><span class="line">  value: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// [LbfsType]: void;</span></span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将2个 NsType &amp; LbsType 省略，将2个对象互传，编辑器不会报错</span></span><br><span class="line"><span class="comment">// 演示过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">acceptNs</span>(<span class="params">momentum: Ns</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Momentum: <span class="subst">$&#123;Momentum.value&#125;</span>Ns`</span>)</span><br><span class="line">&#125;</span><br><span class="line">acceptNs(<span class="keyword">new</span> Lbfs(<span class="number">10</span>)) <span class="comment">// 实际调用传错参数，不会报错，控制台打印：Momentum: 10</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>Subtyping：如果在期望类型 <strong>T</strong> 的实例的任何地方，都可以安全地使用类型 <strong>S</strong> 的实例，那么称类型 <strong>S</strong> 是类型 <strong>T</strong> 的Subtype(亚类型、儿类型)。- 里氏(Liskov substitution principle)替换原则中的一种非正式定义</p>
</blockquote>
<h4 id="Subtyping-的构成"><a href="#Subtyping-的构成" class="headerlink" title="Subtyping 的构成"></a>Subtyping 的构成</h4><ol>
<li><code>Normal Subtyping</code>: 显示声明一个类型是另一个类型的Subtype(亚类型、儿类型)，则二者构成Subtyping 关系</li>
<li><code>Structural Subtyping</code>: 如果一个类型具有另一个类型的所有成员，并且可能还有其他成员，那么前者是后者的Subtype(亚类型、儿类型) - <strong><em>TS使用Structural Subtyping</em></strong></li>
</ol>
<h4 id="Structural-Subtyping-和-Normal-Subtyping-的优缺点"><a href="#Structural-Subtyping-和-Normal-Subtyping-的优缺点" class="headerlink" title="Structural Subtyping 和 Normal Subtyping 的优缺点"></a>Structural Subtyping 和 Normal Subtyping 的优缺点</h4><ol>
<li>Normal Subtyping: 在类型间建立关系，即使类型是外部类型，不在控制范围内；</li>
<li>Structural Subtyping: 默认结构相似不会混淆参数类型</li>
</ol>
<h4 id="在-TS-中模拟-Normal-Subtyping"><a href="#在-TS-中模拟-Normal-Subtyping" class="headerlink" title="在 TS 中模拟 Normal Subtyping"></a>在 TS 中模拟 Normal Subtyping</h4><p>在TS中，<code>unique symbol</code> 生成了一个在所有代码中保持唯一的<code>名称</code>。用户声明的名称绝对不会匹配生成的名称，使用该名称创建一个属性，需要给这个属性定义一个类型，但是我们不关心它的实际值，只是为了区分类型，所以选择了最适合的单元类型<code>void</code>。所以当要创建 <code>NS</code>和<code>Lbfs</code>的Subtype(亚类型、儿类型)，只能显示地继承。</p>
<h3 id="Subtype-亚类型、儿类型-的极端情况"><a href="#Subtype-亚类型、儿类型-的极端情况" class="headerlink" title="Subtype(亚类型、儿类型)的极端情况"></a>Subtype(亚类型、儿类型)的极端情况</h3><ol>
<li>把任何类型赋值给它的类型(Assigning anything to)：<code>any</code>, <code>unknown</code></li>
<li>给任何东西赋值类型(assigning to anything)：<code>any</code>- 从而绕过类型检查</li>
</ol>
<figure class="highlight ts"><figcaption><span>反序列化any</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON.parse()反序列化返回类型是 any</span></span><br><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 只是封装了 JSON.parse() 并返回了 any 类型的一个值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deserialize</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(input)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user: User</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`hi <span class="subst">$&#123;user.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 反序列化一个有效的 User JSON</span></span><br><span class="line">greet(deserialize(<span class="string">&#x27;&#123;&quot;name&quot;: &quot;Alice&quot;&#125;&#x27;</span>))</span><br><span class="line"><span class="comment">// 也可以反序列化一个不是 User 对象的对象</span></span><br><span class="line">greet(<span class="string">&#x27;&#123;&#125;&#x27;</span>) <span class="comment">// 输出hi undefined，因为 `any`会绕过类型检查</span></span><br></pre></td></tr></table></figure>

<h4 id="User的运行时检查-isUser"><a href="#User的运行时检查-isUser" class="headerlink" title="User的运行时检查 - isUser()"></a>User的运行时检查 - isUser()</h4><p>增加一个属性类型检查函数可以规避类型问题，但是仍然存在不足：没有强制调用 <strong>isUser</strong>，所以依然会存在忘记调用而出现的 <code>undefined</code> 的情况</p>
<figure class="highlight ts"><figcaption><span>增加isUser()函数调用前检查类型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deserialize</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(input)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user: User</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`hi <span class="subst">$&#123;user.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查给定实参是否是 User 类型，我们认为，具有 string 类型的 name 属性的变量是 User 类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUser</span>(<span class="params">user: <span class="built_in">any</span></span>): <span class="title">user</span> <span class="title">isUser</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> user.name === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> user: <span class="built_in">any</span> = deserialize(<span class="string">&#x27;&#123;&quot;name&quot;: &#x27;</span>Alice<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">// 在使用之前，先检查 user 是否具有 string类型的name属性</span></span><br><span class="line"><span class="keyword">if</span> (isUser(user)) &#123;</span><br><span class="line">  greet(user)</span><br><span class="line">&#125;</span><br><span class="line">user = <span class="literal">undefined</span></span><br><span class="line"><span class="comment">// 不会执行</span></span><br><span class="line"><span class="keyword">if</span> (isUser(user)) &#123;</span><br><span class="line">  greet(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="顶层类型-Top-Type-unknown"><a href="#顶层类型-Top-Type-unknown" class="headerlink" title="顶层类型(Top Type) - unknown"></a>顶层类型(Top Type) - unknown</h4><blockquote>
<p>如果能够把任何值赋给一个类型，则称为顶层类型，<strong>和类型</strong><code>Object | null | undefined</code> === <code>unknown</code></p>
</blockquote>
<p>一旦忘记调用 <code>isUser</code>，代码在编译过程就会报错 <code>Argument of type &#39;unknown&#39; is not assignable to parameter of type &#39;User&#39;</code></p>
<blockquote>
<p>unknown 和 any 的区别：unknown 需要存在可转换的类型，而 any 不需要直接可用。</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>使用 unknown 的强类型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> User &#123;</span><br><span class="line">  name: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">name: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回 unknown</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deserialize</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">unknown</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(input)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span>(<span class="params">user: User</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`hi <span class="subst">$&#123;user.name&#125;</span>`</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查给定实参是否是 User 类型，我们认为，具有 string 类型的 name 属性的变量是 User 类型</span></span><br><span class="line"><span class="comment">// 实参保持为 any</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUser</span>(<span class="params">user: <span class="built_in">any</span></span>): <span class="title">user</span> <span class="title">isUser</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> user.name === <span class="string">&#x27;string&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将变量声明为 unknown</span></span><br><span class="line"><span class="comment">// 这里一旦有值就会有类型从 any 转换为 unknown，向上转化类型是安全的</span></span><br><span class="line"><span class="keyword">let</span> user: unknown = deserialize(<span class="string">&#x27;&#123;&quot;name&quot;: &#x27;</span>Alice<span class="string">&#x27;&#125;&#x27;</span>)</span><br><span class="line"><span class="comment">// 在使用之前，先检查 user 是否具有 string类型的name属性</span></span><br><span class="line"><span class="keyword">if</span> (isUser(user)) &#123;</span><br><span class="line">  greet(user)</span><br><span class="line">&#125;</span><br><span class="line">user = deserialize(<span class="string">&#x27;null&#x27;</span>)</span><br><span class="line"><span class="comment">// 不会执行</span></span><br><span class="line"><span class="keyword">if</span> (isUser(user)) &#123;</span><br><span class="line">  greet(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="错误情况的值"><a href="#错误情况的值" class="headerlink" title="错误情况的值"></a>错误情况的值</h4><p>一个相反的问题：一种类型可以替代其他类型使用。</p>
<figure class="highlight ts"><figcaption><span>TurnDirection到角度的转换</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> TurnDirection &#123;</span><br><span class="line">  Left,</span><br><span class="line">  Right</span><br><span class="line">&#125;</span><br><span class="line">funtion turnAngle(turn: Turndirection): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(turn) &#123;</span><br><span class="line">    <span class="keyword">case</span> TurnDirection.Left: <span class="keyword">return</span> <span class="number">-90</span>;</span><br><span class="line">    <span class="keyword">case</span> TurnDirection.Right: <span class="keyword">return</span> <span class="number">90</span>;</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Unknown TurnDirection&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>报告错误</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">funtion fail(message: <span class="built_in">string</span>): <span class="built_in">never</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.error(message);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(message)</span><br><span class="line">&#125;</span><br><span class="line">funtion turnAngle(turn: Turndirection): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(turn) &#123;</span><br><span class="line">    <span class="keyword">case</span> TurnDirection.Left: <span class="keyword">return</span> <span class="number">-90</span>;</span><br><span class="line">    <span class="keyword">case</span> TurnDirection.Right: <span class="keyword">return</span> <span class="number">90</span>;</span><br><span class="line">    <span class="keyword">default</span>: fail(<span class="string">&#x27;Unknown TurnDirection&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码可以工作，但是还差一点</span></span><br><span class="line"><span class="comment">// 在严格模式下（使用了 --strict）编辑器会报错</span></span><br><span class="line"><span class="comment">// Function lacks ending return statement and return tyoe does not include &quot;undefined&quot;</span></span><br><span class="line"><span class="comment">// 因为编辑器在 `default` 分支中没有找到 return 语句，所以标记错误</span></span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>使用fail()并返回一个虚拟的值</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">funtion turnAngle(turn: Turndirection): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(turn) &#123;</span><br><span class="line">    <span class="keyword">case</span> TurnDirection.Left: <span class="keyword">return</span> <span class="number">-90</span>;</span><br><span class="line">    <span class="keyword">case</span> TurnDirection.Right: <span class="keyword">return</span> <span class="number">90</span>;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      fail(<span class="string">&#x27;Unknown TurnDirection&#x27;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 因为 fail 会抛出错误，所以永远不会返回这个虚拟值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果后续改变了 fail 的返回，虚拟值就会直接被抛出，不太好，后面还会面临修改，需要另一种解决方案</p>
<figure class="highlight ts"><figcaption><span>使用fail()并返回其结果的turnAngle()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 即使返回never也没问题：因为 never 是所有类型的Subtype(亚类型、儿类型)</span></span><br><span class="line">funtion turnAngle(turn: Turndirection): <span class="built_in">number</span> &#123;</span><br><span class="line">  <span class="keyword">switch</span>(turn) &#123;</span><br><span class="line">    <span class="keyword">case</span> TurnDirection.Left: <span class="keyword">return</span> <span class="number">-90</span>;</span><br><span class="line">    <span class="keyword">case</span> TurnDirection.Right: <span class="keyword">return</span> <span class="number">90</span>;</span><br><span class="line">    <span class="keyword">default</span>: &#123;</span><br><span class="line">      <span class="keyword">return</span> fail(<span class="string">&#x27;Unknown TurnDirection&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果后续需求更新了<code>fail</code>，使其在某些情况不再抛出错误，编译器将强制我们修改<code>fail</code>的返回类型，如果返回类型是<code>void</code>，这时试图将返回的值传递给 string 类型，就不会通过类型检查。</p>
<blockquote>
<p>如果一个类型是其他类型的 Subtype(亚类型、儿类型)，则为底层类型，底层类型是所有类型的 Subtype(亚类型、儿类型) 则需要具有其他类型的成员。因为其他类型可以有无限个类型和成员，所以底层类型也必须有无限个成员，然而这是不可能的。所以底层类型始终是一个空类型：不能为其创建实际值</p>
</blockquote>
<h3 id="允许的替换"><a href="#允许的替换" class="headerlink" title="允许的替换"></a>允许的替换</h3><h4 id="Subtyping-与和类型（Sum-Type）"><a href="#Subtyping-与和类型（Sum-Type）" class="headerlink" title="Subtyping 与和类型（Sum Type）"></a>Subtyping 与和类型（Sum Type）</h4><figure class="highlight ts"><figcaption><span>Trangle | Square 作为 Trangle | Square | Circle</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> TriangleType: unique symbol;</span><br><span class="line"><span class="keyword">class</span> Trangle &#123;</span><br><span class="line">  [TriangleType]: <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// Trangle members</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> SquareType: unique symbol;</span><br><span class="line"><span class="keyword">class</span> Square &#123;</span><br><span class="line">  [SquareType]: <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// Square members</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> CircleType: unique symbol;</span><br><span class="line"><span class="keyword">class</span> Circle &#123;</span><br><span class="line">  [CircleType]: <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// Circle members</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里忽略函数的具体实现</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeShape</span>(<span class="params"></span>): <span class="title">Trangle</span> | <span class="title">Square</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">shape: Trangle | Square | Circle</span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="comment">// draw 接受 Trangle | Square | Circle 这3种类型之一</span></span><br><span class="line"><span class="comment">// 可以运行，makeShape提供的类型少了一个但是是draw可以接受的范围内</span></span><br><span class="line">draw(makeShape())</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>Trangle | Square | Circle 作为 Trangle | Square</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里忽略函数的具体实现</span></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeShape</span>(<span class="params"></span>): <span class="title">Trangle</span> | <span class="title">Square</span> | <span class="title">Circle</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">shape: Trangle | Square</span>):<span class="title">void</span></span>;</span><br><span class="line">draw(makeShape()) <span class="comment">// 无法通过编译，draw 处理不了 Circle</span></span><br></pre></td></tr></table></figure>

<p>当使用<strong>继承</strong>时，得到的 <code>Subtype(亚类型、儿类型)</code> 比 <code>Parent type(双亲类型)</code> 的属性更多。对于<strong>Sum Type</strong>，则是相反的，<code>Parent type(双亲类型)</code> 比 <code>Subtype(亚类型、儿类型)</code> 的类型更多。</p>
<blockquote>
<p>Sum Type: <code>Trangle | Square</code> 是 <code>Trangle | Square | Circle</code> 的 Subtype(亚类型、儿类型)</p>
</blockquote>
<h4 id="Subtyping-and-collections-集合"><a href="#Subtyping-and-collections-集合" class="headerlink" title="Subtyping and collections(集合)"></a>Subtyping and collections(集合)</h4><figure class="highlight ts"><figcaption><span>Triangle[]作为Shape[]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Shape &#123;<span class="comment">/* Shape members */</span>&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> TriangleType: unique symbol;</span><br><span class="line"><span class="comment">// Triangle 是 Shape 的 Subtype(亚类型、儿类型)</span></span><br><span class="line"><span class="keyword">class</span> Triangle <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  [TriangleType]: <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// Triangle members</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeTriangles</span>(<span class="params"></span>): <span class="title">Triangle</span>[]</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">shapes: Shape[]</span>): <span class="title">void</span></span>;</span><br><span class="line">draw(makeTriangles())</span><br></pre></td></tr></table></figure>

<blockquote>
<p>结论：数组会保留它们存储的底层类型的Subtyping关系，反过来则不成立。</p>
</blockquote>
<p><code>Triangle</code> 作为 <code>Shape</code> 的 <code>Subtype(亚类型、儿类型)</code>，则 <code>Triangle[]</code> 是 <code>Shape[]</code>的 <code>Subtype(亚类型、儿类型)</code>，如果 <code>Triangle</code> 可以用作 <code>Shape</code>，那么 <code>Triangle[]</code> 也可以用作 <code>Shape[]</code></p>
<h5 id="LinkedList-lt-Triangle-gt-作为LinkedList-lt-Shape-gt"><a href="#LinkedList-lt-Triangle-gt-作为LinkedList-lt-Shape-gt" class="headerlink" title="LinkedList&lt;Triangle&gt;作为LinkedList&lt;Shape&gt;"></a><code>LinkedList&lt;Triangle&gt;作为LinkedList&lt;Shape&gt;</code></h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个泛型链表集合</span></span><br><span class="line"><span class="keyword">class</span> LinkedList&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  next: LinkedList&lt;T&gt; | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  append(value: T): linkedList&lt;T&gt; &#123;</span><br><span class="line">    <span class="built_in">this</span>.next = <span class="keyword">new</span> LinkedList(value);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.next</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeTriangles</span>(<span class="params"></span>): <span class="title">linkedList</span>&lt;<span class="title">Triangle</span>&gt;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">draw</span>(<span class="params">shapes: linkedList&lt;Shape&gt;</span>): <span class="title">void</span></span>;</span><br><span class="line">draw(makeTriangles()); <span class="comment">// 代码能够编译</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>协变(Covariance)：如果一个类型保留其底层类型的 <code>subtyping</code> 关系，就成该类型具有协变性。数组具有协变性。因为它保留了 <code>subtyping</code> 关系: <code>Triangle</code> 是 <code>Shape</code> 的 <code>Subtype(亚类型、儿类型)</code>，所以 <code>Triangle[]</code> 是 <code>Shape[]</code> 的 <code>Subtype(亚类型、儿类型)</code></p>
</blockquote>
<h4 id="Subtyping-和函数的返回类型"><a href="#Subtyping-和函数的返回类型" class="headerlink" title="Subtyping 和函数的返回类型"></a>Subtyping 和函数的返回类型</h4><h5 id="gt-Triangle-作为-gt-Shape"><a href="#gt-Triangle-作为-gt-Shape" class="headerlink" title="() =&gt; Triangle 作为 () =&gt; Shape"></a>() =&gt; Triangle 作为 () =&gt; Shape</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeTriangle</span>(<span class="params"></span>): <span class="title">Triangle</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeShape</span>(<span class="params"></span>): <span class="title">Shape</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFactory</span>(<span class="params">factory: () =&gt; Shape</span>): <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> factory()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> shape1: Shape = useFactory(makeShape);</span><br><span class="line"><span class="keyword">let</span> shape2: Shape = useFactory(makeTriangle);</span><br><span class="line"><span class="comment">// Shape &lt;---- Triangle // subtying 关系</span></span><br><span class="line"><span class="comment">// () =&gt; Shape &lt;---- () =&gt; Triangle // subtying 关系</span></span><br></pre></td></tr></table></figure>

<p>函数的返回类型具有协变性：如果 <code>Triangle</code> 是 <code>Shape</code> 的 Subtype(亚类型、儿类型)，则可以使用返回 <code>Triangle</code> 替代返回  <code>Shape</code>的函数。反过来则不成立。</p>
<h5 id="gt-Shape-作为-gt-Triangle"><a href="#gt-Shape-作为-gt-Triangle" class="headerlink" title="() =&gt; Shape 作为 () =&gt; Triangle"></a>() =&gt; Shape 作为 () =&gt; Triangle</h5><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeTriangle</span>(<span class="params"></span>): <span class="title">Triangle</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">makeShape</span>(<span class="params"></span>): <span class="title">Shape</span>(<span class="params"></span>)</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useFactory</span>(<span class="params">factory: () =&gt; Triangle</span>): <span class="title">Triangle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> factory()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代码编译错误❌</span></span><br><span class="line"><span class="keyword">let</span> shape1: Shape = useFactory(makeShape);</span><br><span class="line"><span class="keyword">let</span> shape2: Shape = useFactory(makeTriangle);</span><br></pre></td></tr></table></figure>


<h4 id="Subtyping-和函数的实参类型"><a href="#Subtyping-和函数的实参类型" class="headerlink" title="Subtyping 和函数的实参类型"></a>Subtyping 和函数的实参类型</h4><p>带参数的 <code>(argument: Shape) =&gt; void</code> 和 <code>(argument: Triangle) =&gt; void</code> 的关系是什么？</p>
<figure class="highlight ts"><figcaption><span>引入一个render()函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">drawShape</span>(<span class="params">shape: Shape</span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">drawTriangle</span>(<span class="params">triangle: Triangle</span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  triangle: Triangle,</span></span></span><br><span class="line"><span class="function"><span class="params">  drawFunc: ((argument: Triangle) =&gt; <span class="built_in">void</span>); <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  drawFunc(triangle);</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>逆变：如果一个类型颠倒了其底层类型的 subtying 关系，则称该类型具有逆变性。大部分语言中函数的实参是逆变的。</p>
</blockquote>
<p>一个接受 Triangle 作为实参的函数, <code>Shape &lt;---- Triangle</code> 箭头指向代表 subtying 关系, <code>(Shape) =&gt; void ----&gt; (Triangle) =&gt; void</code>  箭头指向代表subtying 关系<br>可以被替换成接口 Shape 作为实参的函数，因为总是可以把 Triangle 传递给一个接受 Shape 作为实参的函数。函数之间的关系与其实参类型之间的关系相反。</p>
<blockquote>
<p>TS是例外，因为TS反过来也成立：传入期望接受 Subtype(亚类型、儿类型) 的函数，而不是期望接受 Parent type(双亲类型)，这是故意作出的设计决策，目的是方便实现常见的 JS 编程模式，不过，可能会导致运行时问题</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>Shape和包含isRightAbgled()方法的Triangle</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Shape &#123;</span><br><span class="line">  <span class="comment">// Shape members</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">const</span> TriangleType: unique symbol;</span><br><span class="line"><span class="keyword">class</span> Triangle <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  [TriangleType]: <span class="built_in">void</span>;</span><br><span class="line">  <span class="comment">// 判断给定的实例是否描述了一个直角三角形</span></span><br><span class="line">  isRightAbgled(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result: <span class="built_in">boolean</span> = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// determine whether it is a right-angled triangle</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// more triangle members</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>反转绘制示例:更新后的绘制和渲染函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">drawShape</span>(<span class="params">shape: Shape</span>): <span class="title">void</span></span>;</span><br><span class="line"><span class="keyword">declare</span> funtion drawTriangle(triangle: Triangle): <span class="built_in">void</span>;</span><br><span class="line"><span class="comment">// render 期望收到 Shape 和一个接受 Shape 作为实参的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  shape: Shape,</span></span></span><br><span class="line"><span class="function"><span class="params">  drawFunc: (argument: Shape) =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  drawFunc(shape)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>试图对Triangle的双亲类型调用isRightAbgled</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">funtion drawTriangle(triangle: Triangle): <span class="built_in">void</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(triangle.isRightAbgled())</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  shape: Shape,</span></span></span><br><span class="line"><span class="function"><span class="params">  drawFunc: (argument: Shape) =&gt; <span class="built_in">void</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  drawFunc(shape)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 Shape 和 drawTriangle 来绘制</span></span><br><span class="line"><span class="comment">// drawTriangle 的实参变成了 Shape，将对 Shape 调用 isRightAbgled()</span></span><br><span class="line"><span class="comment">// 运行时isRightAbgled肯定会报错❌</span></span><br><span class="line"><span class="comment">// 这是实现TS有意作出的决策</span></span><br><span class="line">render(<span class="keyword">new</span> Shape(), drawTriangle)</span><br></pre></td></tr></table></figure>

<p>在 TS 中，如果 Triangle 是 Shape 的 subtype，那么函数类型 <code>(argument: Shape) =&gt; void</code> and <code>(argument: Triangle) =&gt; void</code> 能够彼此替换，互为subtype，这种属性成为双变性（双向协变）。</p>
<h2 id="第八章-面向对象变成的元素-应用subtype"><a href="#第八章-面向对象变成的元素-应用subtype" class="headerlink" title="第八章 - 面向对象变成的元素-应用subtype"></a>第八章 - 面向对象变成的元素-应用subtype</h2><blockquote>
<p>OOP: Object-Oriebted Programming, 面向对象编程。对象可以包含数据和代码，数据是对象的状态，代码是一个或多个方法，也叫「消息」。在面向对象系统中，通过使用其他对象的方法，对象之间可以“对话”或者发送消息。</p>
</blockquote>
<p>OOP关键特征：</p>
<ol>
<li>封装：允许隐藏数据和方法</li>
<li>继承：使用额外的数据和代码扩展一个类型</li>
</ol>
<h3 id="使用接口定义契约"><a href="#使用接口定义契约" class="headerlink" title="使用接口定义契约"></a>使用接口定义契约</h3><p> 接口或契约： 描述了实现该接口的任何对象都理解的<code>一组消息</code>。消息是方法，包括名称，实参和返回类型。接口没有任何状态，相当于书面协议，规定了实现中将提供什么。</p>
<blockquote>
<p>抽象类和接口的区别是什么？</p>
</blockquote>
<ol>
<li>抽象类 <code>ConsoleLogger</code> 和 <code>ALogger</code> 之间的关系是所谓的 <strong>是</strong> 关系，即 <code>ConsoleLogger</code> 继承了 <code>ALogger</code>， 所以它是一个<code>ALogger</code></li>
<li><code>ILogger</code> 定义了一个契约，没有继承，没有创建 <strong>是</strong> 关系，接口可以扩展也可以合并。接口最终让消费者受益，而不是实现接口的类受益。针对接口编程可以降低系统中组件的耦合。</li>
</ol>
<figure class="highlight ts"><figcaption><span>使用抽象类实现日志系统</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ALogger 是一个抽象类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> ALogger &#123;</span><br><span class="line">  <span class="comment">// log 是一个抽象方法，没有实现</span></span><br><span class="line">  <span class="keyword">abstract</span> log(line: <span class="built_in">string</span>): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承了抽象类，实现了 log方法</span></span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">extends</span> ALogger &#123;</span><br><span class="line">  log(line: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>使用接口实现日志系统-这种场景中推荐使用接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> ILogger &#123;</span><br><span class="line">  log(line: sring): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ConsoleLogger <span class="keyword">implements</span> ILogger &#123;</span><br><span class="line">  log(line: <span class="built_in">string</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(line)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>扩展和合并接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展</span></span><br><span class="line"><span class="keyword">interface</span> ILogger &#123;</span><br><span class="line">  log(line: sring): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IExtendedLogger <span class="keyword">extends</span> ILogger &#123;</span><br><span class="line">  warn(line: sring)L <span class="built_in">void</span>;</span><br><span class="line">  error(line: sring)L <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合并</span></span><br><span class="line"><span class="keyword">interface</span> ISpeaker &#123;</span><br><span class="line">  playSound(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IVolumeControl &#123;</span><br><span class="line">  up(): <span class="built_in">void</span>;</span><br><span class="line">  down(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> ISpeakerWithIVolumeControl <span class="keyword">extends</span> ISpeaker, IVolumeControl &#123;</span><br><span class="line">  <span class="comment">// 合并为一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>实现一个 <code>IterableIterator&lt;T&gt;</code>接口` </p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Iterable&lt;T&gt; &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator](): Iterator&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Iterator&lt;T&gt; &#123;</span><br><span class="line">  next(): IteratorResult&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IterableIterator&lt;T&gt; <span class="keyword">extends</span> Iterable, Iterator&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承数据和行为"><a href="#继承数据和行为" class="headerlink" title="继承数据和行为"></a>继承数据和行为</h3><h4 id="「是一个」经验准则"><a href="#「是一个」经验准则" class="headerlink" title="「是一个」经验准则"></a>「是一个」经验准则</h4><figure class="highlight ts"><figcaption><span>不好的继承</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Circle <span class="keyword">extends</span> Point &#123;</span><br><span class="line">  radius: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span>, radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(x, y)</span><br><span class="line">    <span class="built_in">this</span>.radius = radius</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承和 <strong>是一个</strong> 关系： 继承会在 儿类型和双亲类型之间建立一个 <strong>是一个</strong>，如果基类是 Shape，派生类是 Circle，关系就是 <strong><em>Circle是一个Shape</em></strong>，上面 Circle 明显不是一个 Point。</p>
<h4 id="建模层次"><a href="#建模层次" class="headerlink" title="建模层次"></a>建模层次</h4><p>一种场景：当数据模型包含不同层次是，应该考虑继承。</p>
<h4 id="参数化表达式的行为"><a href="#参数化表达式的行为" class="headerlink" title="参数化表达式的行为"></a>参数化表达式的行为</h4><p>另一种场景：大部分行为和状态是多个类型共有的，但是又一小部分行为或状态需要随不同实现而有变化。这里的多个类型应该通过<strong>是一个</strong>测试</p>
<blockquote>
<p>注意⚠️：不要创建出非常深的类层次，否则一个对象的多个状态和方法可能来自层次结构中的不同级别，导致代码难以理解。通常让 subclass 是具体类，让层次结构上方的双亲类是抽象类比较好。 </p>
</blockquote>
<figure class="highlight ts"><figcaption><span>表达式层次结构</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IExpression 不需要是类，因为它不保存状态</span></span><br><span class="line"><span class="keyword">interface</span> IExpression &#123;</span><br><span class="line">  <span class="built_in">eval</span>(): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> BinaryExpression <span class="keyword">implements</span>  &#123;</span><br><span class="line">  <span class="keyword">readonly</span> a: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">readonly</span> b: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">a: <span class="built_in">number</span>, b: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">    <span class="built_in">this</span>.b = b</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 抽象方法</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="built_in">eval</span>(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> SumExpression <span class="keyword">extends</span> BinaryExpression &#123;</span><br><span class="line">  <span class="built_in">eval</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a + <span class="built_in">this</span>.b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> MyExpression <span class="keyword">extends</span> BinaryExpression &#123;</span><br><span class="line">  <span class="built_in">eval</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.a * <span class="built_in">this</span>.b</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> UnaryExpression <span class="keyword">implements</span>  &#123;</span><br><span class="line">  <span class="keyword">readonly</span> a: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">a: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.a = a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 抽象方法</span></span><br><span class="line">  <span class="keyword">abstract</span> <span class="built_in">eval</span>(): <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> UnaryMinusExpression <span class="keyword">extends</span> UnaryExpression &#123;</span><br><span class="line">  <span class="built_in">eval</span>(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="built_in">this</span>.a</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组合数据和行为"><a href="#组合数据和行为" class="headerlink" title="组合数据和行为"></a>组合数据和行为</h3><p>重写或扩展行为，比继承更好 -&gt; 组合</p>
<blockquote>
<p>只要可能就优先选择<strong>组合</strong>而不是继承</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>继承和组合-使用一个Shape</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Shape &#123;</span><br><span class="line">  id: <span class="built_in">string</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">id: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  x: <span class="built_in">number</span>;</span><br><span class="line">  y: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Circle <span class="keyword">extends</span> Shape &#123;</span><br><span class="line">  center: Point;</span><br><span class="line">  radius: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">id: <span class="built_in">string</span>, center: Point, radius: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(id)</span><br><span class="line">    <span class="built_in">this</span>.center = center</span><br><span class="line">    <span class="built_in">this</span>.radius = radius</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="「有一个」经验准则"><a href="#「有一个」经验准则" class="headerlink" title="「有一个」经验准则"></a>「有一个」经验准则</h4><p>组合和 <strong>有一个</strong> 关系： 组合在容器类型和被包含类型之间建立了一个 <strong>有一个</strong> 的关系。如果类型是 <code>Circle</code>， 被包含的类型是 <code>Point</code>，那么他们的关系是 <code>Circle</code>有一个 <code>Point</code></p>
<h4 id="复合类"><a href="#复合类" class="headerlink" title="复合类"></a>复合类</h4><p>可以把复合类的状态的部分声明为私有成员，封装起来，然后使用额外的方法来增强这个复合类，让这些方法来访问实现中的私有成员。</p>
<figure class="highlight ts"><figcaption><span>向CEO提出问题</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CEO &#123;</span><br><span class="line">  isBusy(): <span class="built_in">boolean</span> &#123;&#125;</span><br><span class="line">  answer(question: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> Department &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> Budget &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> Company &#123;</span><br><span class="line">  <span class="keyword">private</span> ceo: CEO = <span class="keyword">new</span> CEO();</span><br><span class="line">  <span class="keyword">private</span> departments: Department[] = []</span><br><span class="line">  <span class="keyword">private</span> budget: Budget = <span class="keyword">new</span> Budget()</span><br><span class="line">  askCEO(question: <span class="built_in">string</span>): <span class="built_in">string</span> | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.ceo.isBusy()) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.ceo.answer(question)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现适配器模式"><a href="#实现适配器模式" class="headerlink" title="实现适配器模式"></a>实现适配器模式</h4><p>适配器模式能够兼容2个不同的类，且不需要修改其中任何一个类。不把几个组件合并到一起，而是封装一个组件，并提供它需要的胶水代码，使其能够作为另一种类型使用。</p>
<figure class="highlight ts"><figcaption><span>一个外部的几何库，但是不适合我们的对象模型</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> GeometryLibrary &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> ICircle &#123;</span><br><span class="line">    getCenterX(): <span class="built_in">number</span>;</span><br><span class="line">    getCenterY(): <span class="built_in">number</span>;</span><br><span class="line">    getDiameter(): <span class="built_in">number</span>; <span class="comment">// 获取直径</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// operations on ICircle omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>CircleAdapter适配器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现了库期望的ICircle接口</span></span><br><span class="line"><span class="keyword">class</span> CircleAdapter <span class="keyword">implements</span> GeometryLibrary.ICircle &#123;</span><br><span class="line">  <span class="keyword">private</span> circle: Circle;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">circle: Circle</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.circle = circle</span><br><span class="line">  &#125;</span><br><span class="line">  getCenterX(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.circle.center.x;</span><br><span class="line">  &#125;</span><br><span class="line">  getCenterY(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.circle.center.y;</span><br><span class="line">  &#125;</span><br><span class="line">  getDiameter(): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.circle.center.radius * <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="扩展数据和行为"><a href="#扩展数据和行为" class="headerlink" title="扩展数据和行为"></a>扩展数据和行为</h3><h4 id="使用组合扩展行为"><a href="#使用组合扩展行为" class="headerlink" title="使用组合扩展行为"></a>使用组合扩展行为</h4><h4 id="使用混入扩展行为"><a href="#使用混入扩展行为" class="headerlink" title="使用混入扩展行为"></a>使用混入扩展行为</h4><p>混入能够减少样板代码，允许混入不同的行为来构成一个对象，以及在多个类型中重用共有的行为。最呵呵实现横切关注点(cross-cutting concern): 程序中影响其他关注点单数不容易被分解的方面，例如引用计数，缓存，持久化等。</p>
<blockquote>
<p>混入：混入通常是使用多重继承实现的（与本章开始的<strong>是一个</strong>经验准则发生了冲突）</p>
</blockquote>
<p>从多重继承的角度看：创建一个 <strong>IHunter</strong> 类来实现捕猎行为，并让所有捕食性动物派生自这个类，这样 <code>Cat</code>既是<code>Animal</code>又是<code>Hunter</code>，混入与继承并不相同，可以只创建一个<code>HunterBehavaior</code>行为类来实现捕猎行为，并让所有捕食性动物包含这种行为。</p>
<blockquote>
<p>混入与包含关系：混入在一个类型与其混入类型之间建立一个包含关系，与 <strong>是一个</strong> 关系不同</p>
</blockquote>
<h4 id="TS-中的混入"><a href="#TS-中的混入" class="headerlink" title="TS 中的混入"></a>TS 中的混入</h4><p>使用 <code>extend()</code>泛型函数，让该函数接受2个不同类型的实例，并把第二个实例的所有成员复制到第一个实例中。</p>
<blockquote>
<p><code>&amp;</code> 交叉类型，交集</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>使用一个实例的成员扩展另一个实例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>&lt;<span class="title">First</span>, <span class="title">Second</span>&gt;(<span class="params">first: First, second: Second</span>): <span class="title">First</span> &amp; <span class="title">Second</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result: unknown = &#123;&#125;</span><br><span class="line">  <span class="comment">// 首先，迭代第一个对象的所有成员，把他们复制到result中</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> prop <span class="keyword">in</span> first) &#123;</span><br><span class="line">    <span class="keyword">if</span> (first.hasOwnProperty(prop)) &#123;</span><br><span class="line">      (&lt;First&gt;result)[prop] = first[prop]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 接下来，对第二个类型的成员做相同的处理</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> prop <span class="keyword">in</span> second) &#123;</span><br><span class="line">    <span class="keyword">if</span> (second.hasOwnProperty(prop)) &#123;</span><br><span class="line">      (&lt;Second&gt;result)[prop] = second[prop]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &lt;First &amp; Second&gt;result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>混入行为</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不定义 Cat， 而是定义 喵喵行为 的宠物类型</span></span><br><span class="line"><span class="comment">// 豹子，猫 都可以喵喵</span></span><br><span class="line"><span class="comment">// 由于没有扩展捕猎行为，所以还不是 Cat</span></span><br><span class="line"><span class="keyword">class</span> MeowingPet <span class="keyword">extends</span> Pet &#123;</span><br><span class="line">  meow(): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> HunterBehavior &#123;</span><br><span class="line">  track(): <span class="built_in">void</span> &#123;&#125;;</span><br><span class="line">  stalk(): <span class="built_in">void</span> &#123;&#125;;</span><br><span class="line">  pounce(): <span class="built_in">void</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> Cat = MeowingPet &amp; HunterBehavior</span><br><span class="line"><span class="keyword">const</span> fluffy: Cat = extend(<span class="keyword">new</span> MeowingPet(), <span class="keyword">new</span> HunterBehavior())</span><br></pre></td></tr></table></figure>

<h4 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h4><figure class="highlight ts"><figcaption><span>跟踪快递单和包裹的状态</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Letter &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> Package &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> Tracking &#123;</span><br><span class="line">  <span class="keyword">private</span> status: <span class="built_in">string</span>;</span><br><span class="line">  constructot(status: <span class="built_in">string</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = status</span><br><span class="line">  &#125;</span><br><span class="line">  updateStatus(status) &#123;</span><br><span class="line">    <span class="built_in">this</span>.status = status</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> TrackingLetter = Letter &amp; Tracking</span><br><span class="line"><span class="keyword">type</span> TrackingTracking = Package &amp; Tracking</span><br></pre></td></tr></table></figure>

<h3 id="纯粹面向对象代码的替代方案"><a href="#纯粹面向对象代码的替代方案" class="headerlink" title="纯粹面向对象代码的替代方案"></a>纯粹面向对象代码的替代方案</h3><h4 id="1-和类型"><a href="#1-和类型" class="headerlink" title="1.和类型"></a>1.和类型</h4><p>如果需要用相同的方式传递不同类型的对象，或者把他们放到一个公共的集合中，他们并非必须实现相同的接口，或者有一个公共的双亲类型。相反，可以利用和类型，就可以不用在类型之间建立任何关系而获得相同的行为。</p>
<h4 id="2-函数式编程"><a href="#2-函数式编程" class="headerlink" title="2.函数式编程"></a>2.函数式编程</h4><p>避免了维护状态，直接计算返回，也不需要改变任何状态，(猜：这里我们可以窥见：既不需要维护状态也不需要改变状态，那么就可以实现 <code>immutable</code>?，所有实参固定成一个引用类型？)</p>
<h4 id="3-泛型编程"><a href="#3-泛型编程" class="headerlink" title="3.泛型编程"></a>3.泛型编程</h4><p>将在第九章，第十章深入介绍。</p>
<h2 id="第九章-泛型数据结构"><a href="#第九章-泛型数据结构" class="headerlink" title="第九章 - 泛型数据结构"></a>第九章 - 泛型数据结构</h2><p>要点：分离关注点；为数据布局使用泛型数据结构；遍历任何数据结构；设置数据处理管道；</p>
<h3 id="解耦关注点"><a href="#解耦关注点" class="headerlink" title="解耦关注点"></a>解耦关注点</h3><figure class="highlight ts"><figcaption><span>getNumbers()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> TransformFunction = <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumbers</span>(<span class="params">transform: TransformFunction</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不需要转换，使用一个默认的doNothing</span></span><br><span class="line"><span class="comment">// doNothing 是恒等函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doNothing</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumbers</span>(<span class="params">transform: TransformFunction = doNothing</span>): <span class="title">number</span>[] </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>assembleWidgets()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PluckFunction = <span class="function">(<span class="params">widgets: Widget[]</span>) =&gt;</span> Widget[];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assembleWidgets</span>(<span class="params">pluck: PluckFunction</span>): <span class="title">AssembleWidget</span>[] </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果不需要转换，使用一个默认的 pluckAll</span></span><br><span class="line"><span class="comment">// pluckAll 是恒等函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pluckAll</span>(<span class="params">widgets: Widget[]</span>): <span class="title">Widget</span>[] </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> widgets;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assembleWidgets</span>(<span class="params">pluck: PluckFunction = pluckAll</span>): <span class="title">AssembleWidget</span>[] </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pluckAll</code> 和 <code>doNothing</code> 非常相似，只是类型不同：都接受一个实参，不做任何处理就返回该实参，2个都是恒等函数。</p>
<blockquote>
<p>代数中定义的恒等函数: <code>f(x) = x</code></p>
</blockquote>
<h4 id="可重用的恒等函数"><a href="#可重用的恒等函数" class="headerlink" title="可重用的恒等函数"></a>可重用的恒等函数</h4><figure class="highlight ts"><figcaption><span>简单的可重用的恒等函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单实用 any 类型</span></span><br><span class="line"><span class="comment">// 当开始使用的时候，会失去类型安全。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>(<span class="params">value: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">x: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 运行时失败❌</span></span><br><span class="line">square(identity(<span class="string">&#x27;hello&#x27;</span>))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类型参数：泛型名称标志符</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>泛型恒等函数</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">identity</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译器足够只能，不需要显示指定 T 是什么类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getNumnbers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  transform: TransformFunction = identity</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span>[] </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assembleWidgets</span>(<span class="params">pluck: PluckFunction = identity</span>): <span class="title">AssembleWidget</span>[] </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 编译❌</span></span><br><span class="line">square(identity(<span class="string">&#x27;hello&#x27;</span>))</span><br></pre></td></tr></table></figure>

<h4 id="可选类型"><a href="#可选类型" class="headerlink" title="可选类型"></a>可选类型</h4><p>泛型类 <code>Optional</code> 类型：当处理没有赋值的情况时，使用的逻辑与该值的实际类型没有关系。<code>Optional</code>可以存储其他任何类型。对 <code>Optional</code> 的修改不会影响 <code>T</code>，而对 <code>T</code> 的修改也不会影响 <code>Optional</code>。这是 <strong><em>泛型编程</em></strong> 极为强大的特征。</p>
<h4 id="泛型类型"><a href="#泛型类型" class="headerlink" title="泛型类型"></a>泛型类型</h4><p>泛型类型：指参数化一个或多个类型的泛型函数，类、接口等。能让代码的组件化程度更高。</p>
<h4 id="习题-1"><a href="#习题-1" class="headerlink" title="习题"></a>习题</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Box&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> value: T;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UnBox</span>&lt;<span class="title">T</span>&gt;(<span class="params">boxed: Box&lt;T&gt;</span>): <span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> boxed.value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="泛型数据布局"><a href="#泛型数据布局" class="headerlink" title="泛型数据布局"></a>泛型数据布局</h3><figure class="highlight ts"><figcaption><span>数字二叉树&字符串链表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字二叉树</span></span><br><span class="line"><span class="keyword">class</span> NumberBinaryTreeNode &#123;</span><br><span class="line">  value: <span class="built_in">number</span>;</span><br><span class="line">  left: NumberBinaryTreeNode | <span class="literal">undefined</span>;</span><br><span class="line">  right: NumberBinaryTreeNode | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 字符串链表</span></span><br><span class="line"><span class="keyword">class</span> StringLinkedListNode &#123;</span><br><span class="line">  value: <span class="built_in">string</span>;</span><br><span class="line">  next: StringLinkedListNode | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: <span class="built_in">string</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="泛型数据结构"><a href="#泛型数据结构" class="headerlink" title="泛型数据结构"></a>泛型数据结构</h4><p>2个例子可以看出 <code>NumberBinaryTreeNode</code> &amp; <code>StringLinkedListNode</code>在数据结构和类型上产生了不必要的耦合。当有新的 <code>StringBinaryTreeNode</code> 时会有冗余代码。</p>
<figure class="highlight ts"><figcaption><span>泛型二叉树</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BinaryTreeNode&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  left: BinaryTreeNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  right: BinaryTreeNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>泛型链表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkedListNode&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">   next: LinkedListNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="什么是数据结构"><a href="#什么是数据结构" class="headerlink" title="什么是数据结构"></a>什么是数据结构</h4><h5 id="包含3个部分："><a href="#包含3个部分：" class="headerlink" title="包含3个部分："></a>包含3个部分：</h5><ol>
<li>数据自身，数据结构包含数据；</li>
<li>数据的形状：例如二叉树，以分层方式布局数据，每层最多2个 children node。</li>
<li>一组保留星座的操作：添加或移除元素。</li>
</ol>
<h5 id="2个关注点："><a href="#2个关注点：" class="headerlink" title="2个关注点："></a>2个关注点：</h5><ol>
<li>数据，包括数据的类型，实例保存的实际值</li>
<li>数据的形状和保留形状的操作。</li>
</ol>
<h4 id="习题-2"><a href="#习题-2" class="headerlink" title="习题"></a>习题</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实现栈，后进先出</span></span><br><span class="line"><span class="keyword">class</span> Stack&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> value: T[] = [];</span><br><span class="line">  <span class="keyword">public</span> push(v: T): T[] &#123;</span><br><span class="line">    <span class="built_in">this</span>.value.push(v)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> pop(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.value?.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> p = <span class="built_in">this</span>.value.pop()</span><br><span class="line">      <span class="keyword">return</span> p</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> peek(): T | <span class="literal">undefined</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.value?.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.value[<span class="built_in">this</span>.value.length - <span class="number">1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现元组</span></span><br><span class="line"><span class="keyword">class</span> Pair&lt;T, U&gt; &#123;</span><br><span class="line">  <span class="keyword">readonly</span> first: T;</span><br><span class="line">  <span class="keyword">readonly</span> second: U;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">f: T, s: U</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.first = f;</span><br><span class="line">    <span class="built_in">this</span>.second = s;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="遍历数据结构"><a href="#遍历数据结构" class="headerlink" title="遍历数据结构"></a>遍历数据结构</h3><blockquote>
<p>中序遍历：递归地找到最深处左侧节点，然后依次遍历双亲节点，右侧节点，最左侧child tree遍历结束后访问该 child tree 的双亲节点，然后访问右侧节点</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>中序打印</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> BinaryTreeNode&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  left: BinaryTreeNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  right: BinaryTreeNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printInOrder</span>&lt;<span class="title">T</span>&gt;(<span class="params">root: BinaryTreeNode&lt;T&gt;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(roor.left) &#123;</span><br><span class="line">    printInOrder(root.left)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(root.value)</span><br><span class="line">  <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">    printInOrder(root.right)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> root: BinaryTreeNode&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> BinaryTreeNode(<span class="number">1</span>)</span><br><span class="line">root.left = <span class="keyword">new</span> BinaryTreeNode(<span class="number">2</span>)</span><br><span class="line">root.left.right = <span class="keyword">new</span> BinaryTreeNode(<span class="number">3</span>)</span><br><span class="line">root.left.right = <span class="keyword">new</span> BinaryTreeNode(<span class="number">4</span>)</span><br><span class="line">printInOrder(rrot)</span><br><span class="line"><span class="comment">// 2 3 1 4</span></span><br></pre></td></tr></table></figure>

<h4 id="使用迭代器"><a href="#使用迭代器" class="headerlink" title="使用迭代器"></a>使用迭代器</h4><p>把遍历逻辑移动到自己的组件中。</p>
<blockquote>
<p>迭代器：能够用来遍历数据结构的一个对象。提供了一个标准结构，将数据结构的实际形状对客户的隐藏起来。</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>自定义迭代器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义迭代器结果</span></span><br><span class="line"><span class="keyword">type</span> IteratorResult&lt;T&gt; = &#123;</span><br><span class="line">  done: <span class="built_in">boolean</span>;</span><br><span class="line">  value: T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器接口</span></span><br><span class="line"><span class="keyword">interface</span> Iterator&lt;T&gt; &#123;</span><br><span class="line">  next(): IteratorResult&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 二叉树迭代器</span></span><br><span class="line"><span class="comment">// 这种实现方式并不是最高效的，因为我们需要队列的元素数量和树的节点数量相同，也就是说，如果树的层次很深，会需要占用较大的内存来存储这个队列</span></span><br><span class="line"><span class="comment">// 后面会有更好的实现，先使用这个作为示例</span></span><br><span class="line"><span class="keyword">class</span> BinaryTreeIterator&lt;T&gt; <span class="keyword">implements</span> Iterator&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> values: T[]; <span class="comment">// 值的队列</span></span><br><span class="line">  <span class="keyword">private</span> root: BinaryTreeNode&lt;T&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">root: BinaryTreeNode&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.values = [];</span><br><span class="line">    <span class="built_in">this</span>.root = root;</span><br><span class="line">    <span class="built_in">this</span>.inOrder(root) <span class="comment">// 构造函数进行中序遍历来填充值的队列</span></span><br><span class="line">  &#125;</span><br><span class="line">  next(): IteratorResult&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 对 next() 的每次调用将通过调用 shift() 从队列中取出值</span></span><br><span class="line">    <span class="keyword">const</span> result: T | <span class="literal">undefined</span> = <span class="built_in">this</span>.values.shift()</span><br><span class="line">    <span class="keyword">if</span> (!result) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: <span class="literal">true</span>,</span><br><span class="line">        value: result</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      done: <span class="literal">false</span>,</span><br><span class="line">      value: result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> inOrder(node: BinaryTreeNode&lt;T&gt;): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (node.left) &#123;</span><br><span class="line">      <span class="built_in">this</span>.inOrder(node.left)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.values.push(node.value)</span><br><span class="line">    <span class="keyword">if</span> (node.right) &#123;</span><br><span class="line">      <span class="built_in">this</span>.inOrder(node.right)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>链表迭代器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkedListIterator&lt;T&gt; <span class="keyword">implements</span> Iterator&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> head: LinkedListNode&lt;T&gt;;</span><br><span class="line">  <span class="keyword">private</span> current: LinkedListNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">head: LinkedListNode&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.head = head</span><br><span class="line">    <span class="built_in">this</span>.current = head</span><br><span class="line">  &#125;</span><br><span class="line">  next():  IteratorResult&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.current) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: <span class="literal">true</span>,</span><br><span class="line">        value: <span class="built_in">this</span>.head.value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> result: T = <span class="built_in">this</span>.current.value</span><br><span class="line">    <span class="built_in">this</span>.current = <span class="built_in">this</span>.current.next</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      done: <span class="literal">false</span>,</span><br><span class="line">      value: result</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>使用迭代器的print()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print()是一个泛型函数，接受一个迭代器作为实参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>&lt;<span class="title">T</span>&gt;(<span class="params">iterator: Iterator&lt;T&gt;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 next 初始化，取出第一个值</span></span><br><span class="line">  <span class="keyword">let</span> result: IteratorResult&lt;T&gt; = iterator.next()</span><br><span class="line">  <span class="keyword">while</span>(!result.done) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.value)</span><br><span class="line">    result = iterator.next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>使用迭代器的contains()</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print()是一个泛型函数，接受一个迭代器作为实参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T, iterator: Iterator&lt;T&gt;</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 next 初始化，取出第一个值</span></span><br><span class="line">  <span class="keyword">let</span> result: IteratorResult&lt;T&gt; = iterator.next()</span><br><span class="line">  <span class="keyword">while</span>(!result.done) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.value === value) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    result = iterator.next()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代器是把数据结构和算法连接起来的胶水，使得这种解耦能够实现。</p>
<h4 id="流水线化迭代代码"><a href="#流水线化迭代代码" class="headerlink" title="流水线化迭代代码"></a>流水线化迭代代码</h4><p>TS中已经预定义了 <code>IteratorResult&lt;T&gt;</code> 和 <code>Iterator&lt;T&gt;</code> 类型</p>
<figure class="highlight ts"><figcaption><span>可迭代的接口</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Iterable&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// [Symbol.iterator] 是 TS 特殊语法，只是代表一个特殊名称。</span></span><br><span class="line">  <span class="comment">// 与 前文中实现 Normal Subtype 技巧类似</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator](): Iterator&lt;T&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>可迭代的链表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkedListNode&lt;T&gt; <span class="keyword">implements</span> Iterable&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  next: LinkedListNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 通过在链表中创建 LinkedListIterator 的新实例来实现 Iterable&lt;T&gt; 接口</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator](): Iterator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedListIterator&lt;T&gt;(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在TS中，Iterable 数据结构允许使用 <code>for...of</code>语法。</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>'使用Iterator实参的print()和contains()'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>&lt;<span class="title">T</span>&gt;(<span class="params">iterator: Iterator&lt;T&gt;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: IteratorResult&lt;T&gt; = iterator.next()</span><br><span class="line">  <span class="keyword">while</span>(!result.done) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(result.value)</span><br><span class="line">    result = iterator.next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T, iterator: Iterator&lt;T&gt;</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: IteratorResult&lt;T&gt; = iterator.next()</span><br><span class="line">  <span class="keyword">while</span>(!result.done) &#123;</span><br><span class="line">    <span class="keyword">if</span> (result.value === value) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    result = iterator.next()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>'使用 Iterable 实参的print()和contains()'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>&lt;<span class="title">T</span>&gt;(<span class="params">iterable: Iterable&lt;T&gt;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">contains</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T, iterable: Iterable&lt;T&gt;</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="comment">// return 可以退出 for...of 循环</span></span><br><span class="line">    <span class="keyword">if</span> (item === value) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>使用生成器的二叉树迭代器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inOrderIterator</span>&lt;<span class="title">T</span>&gt;(<span class="params">root: BinaryTreeNode&lt;T&gt;</span>):<span class="title">IterableIterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> inOrderIterator(root.left)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">yield</span> root.value</span><br><span class="line">    <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> inOrderIterator(root.right)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>使用生成器的链表迭代器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">LinkedListIterator</span>&lt;<span class="title">T</span>&gt;(<span class="params">head: LinkedListNode&lt;T&gt;</span>): <span class="title">IterableIterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> current: LinkedListNode&lt;T&gt; | <span class="literal">undefined</span> = head;</span><br><span class="line">  <span class="keyword">while</span>(current) &#123;</span><br><span class="line">    <span class="keyword">yield</span> current.value;</span><br><span class="line">    current = current.next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>使用生成器的可迭代链表</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkedListNode&lt;T&gt; <span class="keyword">implements</span> Iterable&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  next: LinkedListNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// [Symbol.iterator]() 只是返回 LinkedListIterator 的结果</span></span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator](): Iterator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> LinkedListIterator(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="习题-3"><a href="#习题-3" class="headerlink" title="习题"></a>习题</h4><figure class="highlight ts"><figcaption><span>泛型二叉树的先序遍历&顺序遍历数组</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型二叉树结构</span></span><br><span class="line"><span class="keyword">class</span> BinaryTreeNode&lt;T&gt; &#123;</span><br><span class="line">  value: T;</span><br><span class="line">  left: BinaryTreeNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  right: BinaryTreeNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inOrderIteratorFirst</span>&lt;<span class="title">T</span>&gt;(<span class="params">root: BinaryTreeNode&lt;T&gt;</span>):<span class="title">inOrderIteratorFirst</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">yield</span> root.value</span><br><span class="line">    <span class="keyword">if</span> (root.left) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> inOrderIteratorFirst(root.left)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">if</span> (root.right) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> inOrderIteratorFirst(root.right)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">IteratorArr</span>&lt;<span class="title">T</span>&gt;(<span class="params">array: T[]</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> array) &#123;</span><br><span class="line">    <span class="keyword">yield</span> item;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><blockquote>
<p>迭代器并非是有限的</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>无限随机数据流</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无限随机数据流</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generateRandomNumbers</span>(<span class="params"></span>): <span class="title">IterableIterator</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="built_in">Math</span>.random()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用流中的数字</span></span><br><span class="line"><span class="keyword">let</span> iter: IterableIterator&lt;<span class="built_in">number</span>&gt; = generateRandomNumbers()</span><br><span class="line"><span class="comment">// 迭代器 的调用方式</span></span><br><span class="line"><span class="built_in">console</span>.log(iter.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(iter.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(iter.next().value)</span><br><span class="line"><span class="built_in">console</span>.log(iter.next().value)</span><br></pre></td></tr></table></figure>

<h4 id="处理管道"><a href="#处理管道" class="headerlink" title="处理管道"></a>处理管道</h4><p>处理管道的组件是一些函数，接受一个迭代器作为实参，返回一个迭代器。这种函数可以链接起来。这种模式是反应式编程的基础。</p>
<blockquote>
<p>由前文实现 <code>IterableIterator&lt;T&gt;</code> 方式可知，<code>IterableIterator&lt;T&gt;</code> 是 <code>Iterable&lt;T&gt;</code> 类型的 subtype， 函数实参是双向协变的。所以也可以传入 <code>Iterable&lt;T&gt;</code></p>
</blockquote>
<p>管道是延迟计算的，可以逐个（按调用顺序）处理值</p>
<figure class="highlight ts"><figcaption><span>square & take & 管道</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">square</span>(<span class="params">iter: Iterable&lt;<span class="built_in">number</span>&gt;</span>): <span class="title">IterableIterator</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> iter) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value ** <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">take</span>&lt;<span class="title">T</span>&gt;(<span class="params">iter: Iterable&lt;T&gt;, n: <span class="built_in">number</span></span>): <span class="title">IterableIterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> iter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n-- &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">yield</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> values: IterableIterator&lt;<span class="built_in">number</span>&gt; = take(square(generateRandomNumbers()), <span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> values) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 练习 实现 drop 丢弃一个迭代器的前n个元素而返回其余元素</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">drop</span>&lt;<span class="title">T</span>&gt;(<span class="params">iter: Iterable&lt;T&gt;, n: <span class="built_in">number</span></span>): <span class="title">IterableIterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> [v, k] <span class="keyword">of</span> iter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n-- &gt; <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line">    <span class="keyword">yield</span> value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">count</span>(<span class="params"></span>): <span class="title">IterableIterator</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n: <span class="built_in">number</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    n++</span><br><span class="line">    <span class="keyword">yield</span> n</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> take(drop(count(), <span class="number">5</span>), <span class="number">5</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第十章-泛型算法和迭代器"><a href="#第十章-泛型算法和迭代器" class="headerlink" title="第十章 - 泛型算法和迭代器"></a>第十章 - 泛型算法和迭代器</h2><h3 id="更好的-map-、filter-和reduce"><a href="#更好的-map-、filter-和reduce" class="headerlink" title="更好的 map()、filter()和reduce()"></a>更好的 <code>map()</code>、<code>filter()</code>和<code>reduce()</code></h3><figure class="highlight ts"><figcaption><span>使用迭代器的 map & filter & reduce</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可应用到任何 Iterable&lt;T&gt;,而不只是数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">iter: Iterable&lt;T&gt;, func: (item: T) =&gt; U</span>):<span class="title">IterableIterator</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> iter) &#123;</span><br><span class="line">    <span class="keyword">yield</span> func(value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// pred=谓词</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">filter</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params">iter: Iterable&lt;T&gt;, pred: (item: T) =&gt; <span class="built_in">boolean</span></span>):<span class="title">IterableIterator</span>&lt;<span class="title">U</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> iter) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pred(value)) &#123;</span><br><span class="line">      <span class="keyword">yield</span> func(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">reduce</span>&lt;<span class="title">T</span>&gt;(<span class="params">iter: Iterable&lt;T&gt;, init: T, op: (x: T, y: T) =&gt; T</span>):<span class="title">T</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result: T = init</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> iter) &#123;</span><br><span class="line">    result=op(result, value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="filter-reduce-管道"><a href="#filter-reduce-管道" class="headerlink" title="filter()/reduce()管道"></a><code>filter()/reduce()管道</code></h4><p>从一个二叉树中取出偶数并对它们求和，使用第九章的 <code>BinaryTreeNode&lt;T&gt;</code>，采用中序遍历，并链接到一个偶数过滤函数和使用加法操作的reduce</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root: BinaryTreeNode&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> BinaryTreeNode(<span class="number">1</span>);</span><br><span class="line">root.left = <span class="keyword">new</span> BinaryTreeNode(<span class="number">2</span>);</span><br><span class="line">root.left.right = <span class="keyword">new</span> BinaryTreeNode(<span class="number">3</span>)</span><br><span class="line">root.right = <span class="keyword">new</span> BinaryTreeNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//       1</span></span><br><span class="line"><span class="comment">//    2     4</span></span><br><span class="line"><span class="comment">//     3</span></span><br><span class="line"><span class="comment">// 中序遍历打印结果：2 3 1 4</span></span><br><span class="line"><span class="keyword">const</span> result: <span class="built_in">number</span> = reduce(filter(inOrderIterator(root), <span class="function">(<span class="params">value</span>) =&gt;</span> value % <span class="number">2</span> == <span class="number">0</span>), <span class="number">0</span>, <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<h4 id="习题-4"><a href="#习题-4" class="headerlink" title="习题"></a>习题</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 连接所有非空字符串，处理 string 类型的一个可迭代结构</span></span><br><span class="line"><span class="comment">// reduce + filter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatStrAndFilterEmpty</span>(<span class="params">iter: Iterable&lt;<span class="built_in">string</span>&gt;</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> reduce(filter(iter, <span class="function">(<span class="params">value</span>) =&gt;</span> value.length &gt; <span class="number">0</span>), <span class="string">&#x27;&#x27;</span>, <span class="function">(<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span></span>) =&gt;</span> x + y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 选择所有的奇数并求平方，处理 number 类型的一个可迭代结构</span></span><br><span class="line"><span class="comment">// map + filter</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">squareOdds</span>(<span class="params">iter: Iterable&lt;<span class="built_in">number</span>&gt;</span>): <span class="title">IterableIterator</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> map(filter(iter, <span class="function">(<span class="params">value</span>) =&gt;</span> value % <span class="number">2</span> == <span class="number">1</span>), <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h3><p>实现流畅管道：封装更好的流畅的可迭代结构</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> FluentIterable&lt;T&gt; &#123;</span><br><span class="line">  iter: Iterable&lt;T&gt;;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">iter: Iterable&lt;T&gt;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.iter = iter</span><br><span class="line">  &#125;</span><br><span class="line">  map&lt;U&gt;(func: <span class="function">(<span class="params">item: T</span>) =&gt;</span> U): FluentIterable&lt;U&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FluentIterable(<span class="built_in">this</span>.mapImpl(func))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> *mapImpl&lt;U&gt;(func: <span class="function">(<span class="params">item: T</span>) =&gt;</span> U): IterableIterator&lt;U&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="built_in">this</span>.iter) &#123;</span><br><span class="line">      <span class="keyword">yield</span> func(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  filter&lt;U&gt;(pred: <span class="function">(<span class="params">item: T</span>) =&gt;</span> <span class="built_in">boolean</span>): FluentIterable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FluentIterable(<span class="built_in">this</span>.filterImpl(pred))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> *filterImpl(pred: <span class="function">(<span class="params">item: T</span>) =&gt;</span> <span class="built_in">boolean</span>): IterableIterator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="built_in">this</span>.iter) &#123;</span><br><span class="line">      <span class="keyword">if</span> (pred(value)) &#123;</span><br><span class="line">        <span class="keyword">yield</span> value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 增加take()</span></span><br><span class="line">  take&lt;T&gt;(n: <span class="built_in">number</span>): FluentIterable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FluentIterable(<span class="built_in">this</span>.takeImpl(n))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> *takeImpl&lt;T&gt;(n: <span class="built_in">number</span>): IterableIterator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value <span class="keyword">of</span> <span class="built_in">this</span>.iter) &#123;</span><br><span class="line">      <span class="keyword">if</span> (n-- &lt;= <span class="number">0</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">yield</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 增加drop()</span></span><br><span class="line">  drop&lt;T&gt;(n: <span class="built_in">number</span>): FluentIterable&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FluentIterable(<span class="built_in">this</span>.dropImpl(n))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> *dropImpl&lt;T&gt;(n: <span class="built_in">number</span>): IterableIterator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [v, k] <span class="keyword">of</span> <span class="built_in">this</span>.iter) &#123;</span><br><span class="line">      <span class="keyword">if</span> (n-- &gt; <span class="number">0</span>) <span class="keyword">continue</span></span><br><span class="line">      <span class="keyword">yield</span> value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  reduce(init: T, op: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T): T &#123;</span><br><span class="line">    <span class="keyword">let</span> result: T = init;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">const</span> value <span class="keyword">of</span> <span class="built_in">this</span>.iter) &#123;</span><br><span class="line">      result = op(result, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>应用filter/reduce管道</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> root: BinaryTreeNode&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> BinaryTreeNode(<span class="number">1</span>);</span><br><span class="line">root.left = <span class="keyword">new</span> BinaryTreeNode(<span class="number">2</span>);</span><br><span class="line">root.left.right = <span class="keyword">new</span> BinaryTreeNode(<span class="number">3</span>)</span><br><span class="line">root.right = <span class="keyword">new</span> BinaryTreeNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment">//       1</span></span><br><span class="line"><span class="comment">//    2     4</span></span><br><span class="line"><span class="comment">//     3</span></span><br><span class="line"><span class="comment">// 中序遍历打印结果：2 3 1 4</span></span><br><span class="line"><span class="keyword">const</span> result: <span class="built_in">number</span> = <span class="keyword">new</span> FluentIterable(inOrderIterator(root)).filter(<span class="function"><span class="params">value</span> =&gt;</span> value % <span class="number">2</span> == <span class="number">0</span>).reduce(<span class="number">0</span>, <span class="function">(<span class="params">x, y</span>) =&gt;</span> x + y)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure>

<h3 id="约束类型参数"><a href="#约束类型参数" class="headerlink" title="约束类型参数"></a>约束类型参数</h3><p>约束告诉编译器某个类型实参必须具有的能力（该类型独有的方法，属性等）。一旦要求泛型类型要必须有特定成员，就使用约束将允许类型的集合限制为具有必要成员的那些类型</p>
<figure class="highlight ts"><figcaption><span>使用类型约束的 renderAll</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IRenderable &#123;</span><br><span class="line">  render(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderAll</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">IRenderable</span>&gt;(<span class="params">iter: Iterable&lt;T&gt;</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">const</span> item <span class="keyword">of</span> iter) &#123;</span><br><span class="line">    item.render()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="具有类型约束的泛型算法"><a href="#具有类型约束的泛型算法" class="headerlink" title="具有类型约束的泛型算法"></a>具有类型约束的泛型算法</h4><blockquote>
<p>以实现一个 <code>max()</code> 泛型算法为例</p>
</blockquote>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Icomparable 接口</span></span><br><span class="line"><span class="built_in">enum</span> ComparisonResult &#123;</span><br><span class="line">  LessThan,</span><br><span class="line">  Equal,</span><br><span class="line">  GreeterThan</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Icomparable&lt;T&gt; &#123;</span><br><span class="line">  compareTo(value: T): ComparisonResult;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 迭代器无值的情况下会返回undefined</span></span><br><span class="line"><span class="comment">// 所以不使用 for of循环，而使用 next()手动向前推进迭代器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Icomparable</span>&lt;<span class="title">T</span>&gt;&gt;(<span class="params">iter: Iterable&lt;T&gt;</span>): <span class="title">T</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> iterator: Iterator&lt;T&gt; = iter[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">  <span class="comment">// 取出第一个值</span></span><br><span class="line">  <span class="keyword">let</span> current: IteratorResult&lt;T&gt; = iter.next()</span><br><span class="line">  <span class="keyword">if</span> (current.done) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">let</span> result: T = current.value</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    current = iterator.next()</span><br><span class="line">    <span class="keyword">if</span> (current.done) <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">if</span> (current.value.compareTo(result) == ComparisonResult.GreeterThan) &#123;</span><br><span class="line">      result = current.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 也可以接受一个 compare 方法作为实参</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Icomparable</span>&lt;<span class="title">T</span>&gt;&gt;(<span class="params">iter: Iterable&lt;T&gt;, compare: (x: T, y: T) =&gt; ComparisonResult</span>): <span class="title">T</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> iterator: Iterator&lt;T&gt; = iter[<span class="built_in">Symbol</span>.iterator]()</span><br><span class="line">  <span class="comment">// 取出第一个值</span></span><br><span class="line">  <span class="keyword">let</span> current: IteratorResult&lt;T&gt; = iter.next()</span><br><span class="line">  <span class="keyword">if</span> (current.done) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">let</span> result: T = current.value</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    current = iterator.next()</span><br><span class="line">    <span class="keyword">if</span> (current.done) <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">if</span> (compare(current.value, result) === ComparisonResult.GreeterThan) &#123;</span><br><span class="line">      result = current.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="习题-5"><a href="#习题-5" class="headerlink" title="习题"></a>习题</h4><p>实现一个泛型函数 <code>Clamp(value, min, max)</code>, 如果 `min &lt; value &lt; max ? value : (value &lt;= min ? min : max)</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enum</span> ComparisonResult &#123;</span><br><span class="line">  LessThan,</span><br><span class="line">  Equal,</span><br><span class="line">  GreeterThan</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> Icomparable&lt;T&gt; &#123;</span><br><span class="line">  compareTo(value: T): ComparisonResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clamp</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">Icomparable</span>&lt;<span class="title">T</span>&gt;&gt;(<span class="params">v: T, min: T, max: T</span>): <span class="title">T</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">if</span> (value.compareTo(min) === ComparisonResult.LessThan) <span class="keyword">return</span> min</span><br><span class="line">  <span class="keyword">if</span> (value.compareTo(max) === ComparisonResult.GreeterThan) <span class="keyword">return</span> max</span><br><span class="line">  <span class="keyword">return</span> value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="高效-reverse-和其他使用迭代器的算法"><a href="#高效-reverse-和其他使用迭代器的算法" class="headerlink" title="高效 reverse 和其他使用迭代器的算法"></a>高效 reverse 和其他使用迭代器的算法</h3><blockquote>
<p>使用一个栈存储来实现<code>reverse</code>的空间是O(n)，时间也是T(n)，都是线性的；使用数组交换两头来实现<code>reverse</code>的空间是O(1)，只用了一个临时变量，时间是T(n/2)</p>
</blockquote>
<h4 id="迭代器的基础模块"><a href="#迭代器的基础模块" class="headerlink" title="迭代器的基础模块"></a>迭代器的基础模块</h4><p>判断迭代器合适应该停止=捕获2个迭代器相同的时机：重新定义为一组接口，公开一个<code>get()</code>方法，用于返回<code>T</code>类型的一个值，使用这个方法从迭代器中读取值</p>
<figure class="highlight ts"><figcaption><span>'IReadable<T>, IIncrementable<T>, IInputIterator<T>'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get() 用于获取迭代器当前的值</span></span><br><span class="line"><span class="keyword">interface</span> IReadable&lt;T&gt; &#123;</span><br><span class="line">  get(): T;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// increment() 用于将迭代器推进到下一个元素</span></span><br><span class="line"><span class="keyword">interface</span> IIncrementable&lt;T&gt; &#123;</span><br><span class="line">  increment(): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IInputIterator&lt;T&gt; <span class="keyword">extends</span> IReadable&lt;T&gt;, IIncrementable&lt;T&gt; &#123;</span><br><span class="line">  equals(other: IInputIterator): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为链表实现一个满足新的 <code>IInputIterator&lt;T&gt;</code> 接口的 <code>LinkedListInputIterator&lt;T&gt;</code></p>
<blockquote>
<p>输入迭代器: 能够遍历序列一次并提供其值的迭代器，不能第二次重放值。并非必须遍历持久性数据结构，也可以从生成器或者其他某种数据源提供值。</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>链表输入迭代器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> LinkedListInputIterator&lt;T&gt; <span class="keyword">implements</span> IInputIterator&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> node: LinkedListNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">node: LinkedListNode&lt;T&gt; | <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.node = node</span><br><span class="line">  &#125;</span><br><span class="line">  increment(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.node) <span class="keyword">throw</span> <span class="built_in">Error</span>();</span><br><span class="line">    <span class="built_in">this</span>.node = <span class="built_in">this</span>.node.next</span><br><span class="line">  &#125;</span><br><span class="line">  get(): T &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.node) <span class="keyword">throw</span> <span class="built_in">Error</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.node.value</span><br><span class="line">  &#125;</span><br><span class="line">  equals(other: IInputIterator&lt;T&gt;): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.node == (&lt;LinkedListInputIterator&lt;T&gt;&gt;other).node</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用：链表上的一对迭代器</span></span><br><span class="line"><span class="keyword">const</span> head: LinkedListNode&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> LinkedListNode(<span class="number">0</span>)</span><br><span class="line">head.next = <span class="keyword">new</span> LinkedListNode(<span class="number">1</span>)</span><br><span class="line">head.next.next = <span class="keyword">new</span> LinkedListNode(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">let</span> begin: IInputIterator&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> LinkedListInputIterator(head)</span><br><span class="line"><span class="comment">// end 的值是 undefined</span></span><br><span class="line"><span class="keyword">let</span> end: IInputIterator&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> LinkedListInputIterator(<span class="literal">undefined</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输出迭代器: 能够遍历一个序列并向其卸任值的迭代器，并不需要能够读值。同样的，并非必须遍历持久性数据结构，也可以把值卸任其他输出。</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>'IWritable<T> and IOutputIterator<T>'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IWritable&lt;T&gt; &#123;</span><br><span class="line">  set(value: T): <span class="built_in">void</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> IOutputIterator&lt;T&gt; <span class="keyword">extends</span> IWritable&lt;T&gt;, IIncrementable&lt;T&gt; &#123;</span><br><span class="line">  equals(other: IOutputIterator&lt;T&gt;): <span class="built_in">boolean</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个写入到控制台的输出迭代器：写入到输出流。例如：网络连接，标准输出，标准错误等，但是不能读值。</p>
<figure class="highlight ts"><figcaption><span>控制台输出迭代器</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ConsoleOutputIterator&lt;T&gt; <span class="keyword">implements</span> IOutputIterator&lt;T&gt; &#123;</span><br><span class="line">  set(value: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这个例子没有遍历数据结构，所以可以啥也不做</span></span><br><span class="line">  increment(): <span class="built_in">void</span> &#123;&#125;</span><br><span class="line">  equals(other: IOutputIterator&lt;T&gt;): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="comment">// 始终返回false，因为写入控制台没有可以比较的序列末尾</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>具有输入和输出迭代器的map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  begin: IInputIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  end: IInputIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  out: IOutputIterator&lt;U&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  func: (value: T) =&gt; U</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (!begin.equals(end)) &#123;</span><br><span class="line">    out.set(func(begin.get()))</span><br><span class="line">    begin.increment()</span><br><span class="line">    out.increment()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="有用的find"><a href="#有用的find" class="headerlink" title="有用的find()"></a><code>有用的find()</code></h4><p>前向迭代器：向前推进，可以读取当前位置的值以及更新该值的迭代器。前向迭代器也可以被克隆，使得推进该迭代器不会影响该迭代器的克隆。跟输入输出迭代器不同，它可以多次遍历一个序列。在推进原迭代器时，副本迭代器不会移动，是独立的。因此它可以多次遍历。</p>
<figure class="highlight ts"><figcaption><span>'IForwardIterator<T> and LinkedListIterator<T> 实现 IForwardIterator<T>'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IForwardIterator&lt;T&gt; <span class="keyword">extends</span> IReadable&lt;T&gt;, IWritable, IIncrementable&lt;T&gt; &#123;</span><br><span class="line">  equals(other: IForwardIterator&lt;T&gt;): <span class="built_in">boolean</span>;</span><br><span class="line">  clone(): IForwardIterator&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> LinkedListIterator&lt;T&gt; <span class="keyword">implements</span> IForwardIterator&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> node: LinkedListNode&lt;T&gt; | <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">node: LinkedListNode&lt;T&gt; | <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.node = node</span><br><span class="line">  &#125;</span><br><span class="line">  increment(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.node) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">this</span>.node = <span class="built_in">this</span>.node.next</span><br><span class="line">  &#125;</span><br><span class="line">  get(): T &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.node) <span class="keyword">throw</span> <span class="built_in">Error</span>()</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.node.value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set() 是 IWritable&lt;T&gt; 需要的一个额外的方法，用于封信链表节点的值</span></span><br><span class="line">  set(value: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">this</span>.node) <span class="keyword">throw</span> <span class="built_in">Error</span>()</span><br><span class="line">    <span class="built_in">this</span>.node.value = value</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// equals 现在期望收到另外一个 IForwardIterator&lt;T&gt;</span></span><br><span class="line">  equals(other: IForwardIterator&lt;T&gt;): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.node = (&lt;LinkedListIterator&lt;T&gt;&gt;other).node</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="comment">//  创建一个新的迭代器，指向与当前迭代器相同的节点</span></span><br><span class="line">  clone(): IForwardIterator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LinkedListIterator(<span class="built_in">this</span>.node)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>使用前向迭代器的find</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span>&lt;<span class="title">T</span>&gt; (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  begin: IForwardIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  end: IForwardIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  pred: (value: T) =&gt; booean</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">IForwardIterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!begin.equals(end)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (pred(begin.equals(end))) &#123;</span><br><span class="line">      <span class="keyword">return</span> begin</span><br><span class="line">    &#125;</span><br><span class="line">    begin.increment()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> end</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 应用：将链表中的42替换为0</span></span><br><span class="line"><span class="keyword">let</span> head: LinkedListNode&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> LinkedListNode(<span class="number">1</span>)</span><br><span class="line">head.next = <span class="keyword">new</span> LinkedListNode(<span class="number">2</span>)</span><br><span class="line">head.next.next = <span class="keyword">new</span> LinkedListNode(<span class="number">42</span>)</span><br><span class="line"><span class="keyword">let</span> begin: IForwardIterator&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> IForwardIterator(head)</span><br><span class="line"><span class="keyword">let</span> end: IForwardIterator&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> IForwardIterator(<span class="literal">undefined</span>)</span><br><span class="line"><span class="keyword">let</span> iter: IForwardIterator&lt;<span class="built_in">number</span>&gt; = find(begin, end, <span class="function">(<span class="params">value: <span class="built_in">number</span></span>) =&gt;</span> value == <span class="number">42</span>)</span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">if</span> (!iter.equals(end)) &#123;</span><br><span class="line">  iter.set(<span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="高效的reverse"><a href="#高效的reverse" class="headerlink" title="高效的reverse()"></a>高效的<code>reverse()</code></h4><p>数组实现<code>reverse()</code>时是从数组的两端开始互换元素，一直递增前向索引。递减后向索引，直到两者相遇。</p>
<blockquote>
<p>双向迭代器：不仅具有前向迭代器的所有能力，而且还可以递减。既能前向，又能后向遍历。可以读写当前元素的值，克隆自己，以及向前或向后步进。</p>
</blockquote>
<p>链表不支持后向迭代，但是可以使用一个双向链表保存其前导节点和后继节点的引用。</p>
<figure class="highlight ts"><figcaption><span>'IBiddirectionalIterator<T> and ArrayIterator<T>'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IBiddirectionalIterator&lt;T&gt; <span class="keyword">extends</span> IReadable&lt;T&gt;, IWritable&lt;T&gt;, IIncrementable&lt;T&gt; &#123;</span><br><span class="line">  decrement(): <span class="built_in">void</span>;</span><br><span class="line">  equals(other: IBiddirectionalIterator&lt;T&gt;): <span class="built_in">boolean</span>;</span><br><span class="line">  clone(): IBiddirectionalIterator&lt;T&gt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ArrayIterator&lt;T&gt; <span class="keyword">implements</span> IBiddirectionalIterator&lt;T&gt; &#123;</span><br><span class="line">  <span class="keyword">private</span> array: T[];</span><br><span class="line">  <span class="keyword">private</span> index: <span class="built_in">number</span>;</span><br><span class="line">  <span class="keyword">constructor</span>(<span class="params">array: T[], index: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.array = array;</span><br><span class="line">    <span class="built_in">this</span>.index = index</span><br><span class="line">  &#125;</span><br><span class="line">  get(): T &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.array(<span class="built_in">this</span>.index)</span><br><span class="line">  &#125;</span><br><span class="line">  set(value: T): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.array(<span class="built_in">this</span>.index) = value</span><br><span class="line">  &#125;</span><br><span class="line">  increment(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.index++</span><br><span class="line">  &#125;</span><br><span class="line">  decrement(): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.index--</span><br><span class="line">  &#125;</span><br><span class="line">  equals(other: IBiddirectionalIterator&lt;T&gt;): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.index == (&lt;ArrayIterator&lt;T&gt;&gt;other).index</span><br><span class="line">  &#125;</span><br><span class="line">  clone(): IBiddirectionalIterator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayIterator(<span class="built_in">this</span>.array, <span class="built_in">this</span>.index)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>使用双向迭代器的reverse</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span>&lt;<span class="title">T</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  begin: IBiddirectionalIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  end: IBiddirectionalIterator&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!begin.equals(end)) &#123;</span><br><span class="line">    <span class="comment">// end 从数组末尾后面的一个元素开始，所以在使用之前需要递减</span></span><br><span class="line">    end.decrement()</span><br><span class="line">    <span class="keyword">if</span> (begin.equals(end)) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">const</span> tmp: T = begin.get()</span><br><span class="line">    begin.set(end.get())</span><br><span class="line">    end.set(temp)</span><br><span class="line">    begin.increment()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 翻转一个数值数组</span></span><br><span class="line"><span class="keyword">let</span> array: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> begin: IBiddirectionalIterator&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> ArrayIterator(array, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">let</span> end: IBiddirectionalIterator&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> ArrayIterator(array, array.length) <span class="comment">// 将数组的end迭代器初始化为索引长度，所以初始array[end]值为undefined</span></span><br><span class="line">reverse(begin, end)</span><br><span class="line"><span class="built_in">console</span>.log(array) <span class="comment">// [5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>

<h4 id="高效地获取元素"><a href="#高效地获取元素" class="headerlink" title="高效地获取元素"></a>高效地获取元素</h4><p>随机访问迭代器：能够以O(1)时间向前或向后跳过任意多元素。可以读写当前元素的值、克隆自己以及向前或向后移动任意元素。</p>
<blockquote>
<p>数组可以通过索引快速获取任何元素，但是双向链表/链表均不支持随机访问迭代器。</p>
</blockquote>
<figure class="highlight ts"><figcaption><span>'IRandomAccessIterator<T> & 更新后的 ArrayIterator<T>'</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> IRandomAccessIterator&lt;T&gt; <span class="keyword">extends</span> IReadable&lt;T&gt;, IWritable&lt;T&gt;, IIncrementable&lt;T&gt; &#123;</span><br><span class="line">  decrement(): <span class="built_in">void</span>;</span><br><span class="line">  equals(other: IRandomAccessIterator&lt;T&gt;): <span class="built_in">boolean</span>;</span><br><span class="line">  clone(): IRandomAccessIterator&lt;T&gt;;</span><br><span class="line">  move(n: <span class="built_in">number</span>): <span class="built_in">void</span>;</span><br><span class="line">  distance(other: IRandomAccessIterator&lt;T&gt;): <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> ArrayIterator&lt;T&gt; <span class="keyword">implements</span> IRandomAccessIterator&lt;T&gt; &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 与上面相同的部分</span></span><br><span class="line">  <span class="comment">// 更新</span></span><br><span class="line">  equals(other: IRandomAccessIterator&lt;T&gt;): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.index == (&lt;ArrayIterator&lt;T&gt;&gt;other).index</span><br><span class="line">  &#125;</span><br><span class="line">  clone(): IRandomAccessIterator&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ArrayIterator(<span class="built_in">this</span>.array, <span class="built_in">this</span>.index)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 将迭代器推进 n 个步长（n 可以是负数，代表向后移动）</span></span><br><span class="line">  move(n: <span class="built_in">number</span>): <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.index += n</span><br><span class="line">  &#125;</span><br><span class="line">  distance(other: IRandomAccessIterator&lt;T&gt;): <span class="built_in">number</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.index - (&lt;ArrayIterator&lt;T&gt;&gt;other).index</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现一个 <code>elementAt()</code> 算法，返回只想序列中第n个元素的迭代器。使用一个输入迭代器来实现时：需要递增迭代器 <code>n</code> 次此案达到期望的原色，时间复杂度为 O(n)；使用随机访问迭代器时，时间复杂度为 O(1)；</p>
<figure class="highlight ts"><figcaption><span>访问指定位置的元素</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elementAtRandomAccessIterator</span>&lt;<span class="title">T</span>&gt; (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  begin: IRandomAccessIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  end: IRandomAccessIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  n: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">IRandomAccessIterator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="comment">// 移动 n 个元素</span></span><br><span class="line">  begin.move(n)</span><br><span class="line">  <span class="keyword">if</span> (begin.distance(end) &lt;= <span class="number">0</span>) <span class="keyword">return</span> end;</span><br><span class="line">  <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="自适应算法"><a href="#自适应算法" class="headerlink" title="自适应算法"></a>自适应算法</h3><figure class="highlight ts"><figcaption><span>使用输入迭代器的elementAt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elementAtForwardIterator</span>&lt;<span class="title">T</span>&gt; (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  begin: IForwardIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  end: IForwardIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  n: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">IForwardIterator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!begin.equals(end) &amp;&amp; n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    begin.increment()</span><br><span class="line">    n--</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> begin</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight ts"><figcaption><span>自适应的elementAt</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isRandomAccessIterator</span>&lt;<span class="title">T</span>&gt; (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  iter: IForwardIterator&lt;T&gt;</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">iter</span> <span class="title">is</span> <span class="title">IRandomAccessIterator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;distabce&#x27;</span> <span class="keyword">in</span> iter</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">elementAt</span>&lt;<span class="title">T</span>&gt; (<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  begin: IForwardIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  end: IForwardIterator&lt;T&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  n: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">IForwardIterator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(isRandomAccessIterator(begin) &amp;&amp; isRandomAccessIterator(end)) &#123;</span><br><span class="line">    <span class="keyword">return</span> elementAtRandomAccessIterator(begin, end, n)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elementAtForwardIterator(begin, end, n)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/typeScript-javaScript-%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F/" rel="tag"># typeScript, javaScript, 编程与类型系统</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/11/ilearnVue3/" rel="prev" title="Vue & Mutable">
      <i class="fa fa-chevron-left"></i> Vue & Mutable
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/01/11/ilearnFrancais/" rel="next" title="Français">
      Français <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-Subtyping-%E5%84%BF%E7%B1%BB%E5%9E%8B%E5%85%B3%E7%B3%BB"><span class="nav-number">1.</span> <span class="nav-text">第七章 - Subtyping 儿类型关系</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%9C%A8TS%E4%B8%AD%E5%8C%BA%E5%88%86%E7%9B%B8%E4%BC%BC%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.1.</span> <span class="nav-text">在TS中区分相似的类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Subtyping-%E7%9A%84%E6%9E%84%E6%88%90"><span class="nav-number">1.1.1.</span> <span class="nav-text">Subtyping 的构成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Structural-Subtyping-%E5%92%8C-Normal-Subtyping-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="nav-number">1.1.2.</span> <span class="nav-text">Structural Subtyping 和 Normal Subtyping 的优缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%9C%A8-TS-%E4%B8%AD%E6%A8%A1%E6%8B%9F-Normal-Subtyping"><span class="nav-number">1.1.3.</span> <span class="nav-text">在 TS 中模拟 Normal Subtyping</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Subtype-%E4%BA%9A%E7%B1%BB%E5%9E%8B%E3%80%81%E5%84%BF%E7%B1%BB%E5%9E%8B-%E7%9A%84%E6%9E%81%E7%AB%AF%E6%83%85%E5%86%B5"><span class="nav-number">1.2.</span> <span class="nav-text">Subtype(亚类型、儿类型)的极端情况</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#User%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E6%A3%80%E6%9F%A5-isUser"><span class="nav-number">1.2.1.</span> <span class="nav-text">User的运行时检查 - isUser()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%A1%B6%E5%B1%82%E7%B1%BB%E5%9E%8B-Top-Type-unknown"><span class="nav-number">1.2.2.</span> <span class="nav-text">顶层类型(Top Type) - unknown</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%99%E8%AF%AF%E6%83%85%E5%86%B5%E7%9A%84%E5%80%BC"><span class="nav-number">1.2.3.</span> <span class="nav-text">错误情况的值</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%81%E8%AE%B8%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.3.</span> <span class="nav-text">允许的替换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Subtyping-%E4%B8%8E%E5%92%8C%E7%B1%BB%E5%9E%8B%EF%BC%88Sum-Type%EF%BC%89"><span class="nav-number">1.3.1.</span> <span class="nav-text">Subtyping 与和类型（Sum Type）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Subtyping-and-collections-%E9%9B%86%E5%90%88"><span class="nav-number">1.3.2.</span> <span class="nav-text">Subtyping and collections(集合)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LinkedList-lt-Triangle-gt-%E4%BD%9C%E4%B8%BALinkedList-lt-Shape-gt"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">LinkedList&lt;Triangle&gt;作为LinkedList&lt;Shape&gt;</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Subtyping-%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">Subtyping 和函数的返回类型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#gt-Triangle-%E4%BD%9C%E4%B8%BA-gt-Shape"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">() &#x3D;&gt; Triangle 作为 () &#x3D;&gt; Shape</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#gt-Shape-%E4%BD%9C%E4%B8%BA-gt-Triangle"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">() &#x3D;&gt; Shape 作为 () &#x3D;&gt; Triangle</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Subtyping-%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E5%8F%82%E7%B1%BB%E5%9E%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">Subtyping 和函数的实参类型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8F%98%E6%88%90%E7%9A%84%E5%85%83%E7%B4%A0-%E5%BA%94%E7%94%A8subtype"><span class="nav-number">2.</span> <span class="nav-text">第八章 - 面向对象变成的元素-应用subtype</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E5%A5%91%E7%BA%A6"><span class="nav-number">2.1.</span> <span class="nav-text">使用接口定义契约</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0"><span class="nav-number">2.1.1.</span> <span class="nav-text">练习</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%A7%E6%89%BF%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.2.</span> <span class="nav-text">继承数据和行为</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%8C%E6%98%AF%E4%B8%80%E4%B8%AA%E3%80%8D%E7%BB%8F%E9%AA%8C%E5%87%86%E5%88%99"><span class="nav-number">2.2.1.</span> <span class="nav-text">「是一个」经验准则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BB%BA%E6%A8%A1%E5%B1%82%E6%AC%A1"><span class="nav-number">2.2.2.</span> <span class="nav-text">建模层次</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E5%8C%96%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.2.3.</span> <span class="nav-text">参数化表达式的行为</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.3.</span> <span class="nav-text">组合数据和行为</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E3%80%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E3%80%8D%E7%BB%8F%E9%AA%8C%E5%87%86%E5%88%99"><span class="nav-number">2.3.1.</span> <span class="nav-text">「有一个」经验准则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%8D%E5%90%88%E7%B1%BB"><span class="nav-number">2.3.2.</span> <span class="nav-text">复合类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9E%E7%8E%B0%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.3.3.</span> <span class="nav-text">实现适配器模式</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E6%95%B0%E6%8D%AE%E5%92%8C%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.4.</span> <span class="nav-text">扩展数据和行为</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BB%84%E5%90%88%E6%89%A9%E5%B1%95%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.4.1.</span> <span class="nav-text">使用组合扩展行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%B7%B7%E5%85%A5%E6%89%A9%E5%B1%95%E8%A1%8C%E4%B8%BA"><span class="nav-number">2.4.2.</span> <span class="nav-text">使用混入扩展行为</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TS-%E4%B8%AD%E7%9A%84%E6%B7%B7%E5%85%A5"><span class="nav-number">2.4.3.</span> <span class="nav-text">TS 中的混入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98"><span class="nav-number">2.4.4.</span> <span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%AF%E7%B2%B9%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="nav-number">2.5.</span> <span class="nav-text">纯粹面向对象代码的替代方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-%E5%92%8C%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.5.1.</span> <span class="nav-text">1.和类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.函数式编程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="nav-number">2.5.3.</span> <span class="nav-text">3.泛型编程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.</span> <span class="nav-text">第九章 - 泛型数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A3%E8%80%A6%E5%85%B3%E6%B3%A8%E7%82%B9"><span class="nav-number">3.1.</span> <span class="nav-text">解耦关注点</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%87%8D%E7%94%A8%E7%9A%84%E6%81%92%E7%AD%89%E5%87%BD%E6%95%B0"><span class="nav-number">3.1.1.</span> <span class="nav-text">可重用的恒等函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%AF%E9%80%89%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.2.</span> <span class="nav-text">可选类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.1.3.</span> <span class="nav-text">泛型类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-1"><span class="nav-number">3.1.4.</span> <span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%B8%83%E5%B1%80"><span class="nav-number">3.2.</span> <span class="nav-text">泛型数据布局</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B3%9B%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.1.</span> <span class="nav-text">泛型数据结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.2.</span> <span class="nav-text">什么是数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8C%85%E5%90%AB3%E4%B8%AA%E9%83%A8%E5%88%86%EF%BC%9A"><span class="nav-number">3.2.2.1.</span> <span class="nav-text">包含3个部分：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2%E4%B8%AA%E5%85%B3%E6%B3%A8%E7%82%B9%EF%BC%9A"><span class="nav-number">3.2.2.2.</span> <span class="nav-text">2个关注点：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-2"><span class="nav-number">3.2.3.</span> <span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%81%8D%E5%8E%86%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.3.</span> <span class="nav-text">遍历数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">3.3.1.</span> <span class="nav-text">使用迭代器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E5%8C%96%E8%BF%AD%E4%BB%A3%E4%BB%A3%E7%A0%81"><span class="nav-number">3.3.2.</span> <span class="nav-text">流水线化迭代代码</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-3"><span class="nav-number">3.3.3.</span> <span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="nav-number">3.4.</span> <span class="nav-text">数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E7%AE%A1%E9%81%93"><span class="nav-number">3.4.1.</span> <span class="nav-text">处理管道</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-number">4.</span> <span class="nav-text">第十章 - 泛型算法和迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E5%A5%BD%E7%9A%84-map-%E3%80%81filter-%E5%92%8Creduce"><span class="nav-number">4.1.</span> <span class="nav-text">更好的 map()、filter()和reduce()</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#filter-reduce-%E7%AE%A1%E9%81%93"><span class="nav-number">4.1.1.</span> <span class="nav-text">filter()&#x2F;reduce()管道</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-4"><span class="nav-number">4.1.2.</span> <span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95"><span class="nav-number">4.2.</span> <span class="nav-text">常用算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%A6%E6%9D%9F%E7%B1%BB%E5%9E%8B%E5%8F%82%E6%95%B0"><span class="nav-number">4.3.</span> <span class="nav-text">约束类型参数</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B7%E6%9C%89%E7%B1%BB%E5%9E%8B%E7%BA%A6%E6%9D%9F%E7%9A%84%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-number">4.3.1.</span> <span class="nav-text">具有类型约束的泛型算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B9%A0%E9%A2%98-5"><span class="nav-number">4.3.2.</span> <span class="nav-text">习题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AB%98%E6%95%88-reverse-%E5%92%8C%E5%85%B6%E4%BB%96%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-number">4.4.</span> <span class="nav-text">高效 reverse 和其他使用迭代器的算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E7%9A%84%E5%9F%BA%E7%A1%80%E6%A8%A1%E5%9D%97"><span class="nav-number">4.4.1.</span> <span class="nav-text">迭代器的基础模块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%9C%89%E7%94%A8%E7%9A%84find"><span class="nav-number">4.4.2.</span> <span class="nav-text">有用的find()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E7%9A%84reverse"><span class="nav-number">4.4.3.</span> <span class="nav-text">高效的reverse()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%AB%98%E6%95%88%E5%9C%B0%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0"><span class="nav-number">4.4.4.</span> <span class="nav-text">高效地获取元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E7%AE%97%E6%B3%95"><span class="nav-number">4.5.</span> <span class="nav-text">自适应算法</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">主体-客体联合创作</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">主体-客体联合创作</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
